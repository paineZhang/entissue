// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"fmt"
	"sync"
	"time"
	"wing/models/ent/auth"
	"wing/models/ent/jobhistory"
	"wing/models/ent/organization"
	"wing/models/ent/orgunit"
	"wing/models/ent/orgunitmember"
	"wing/models/ent/orgunitposition"
	"wing/models/ent/predicate"
	"wing/models/ent/resource"
	"wing/models/ent/system"
	"wing/models/ent/user"

	"entgo.io/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAuth            = "Auth"
	TypeJobHistory      = "JobHistory"
	TypeOrgUnit         = "OrgUnit"
	TypeOrgUnitMember   = "OrgUnitMember"
	TypeOrgUnitPosition = "OrgUnitPosition"
	TypeOrganization    = "Organization"
	TypeResource        = "Resource"
	TypeSystem          = "System"
	TypeUser            = "User"
)

// AuthMutation represents an operation that mutates the Auth nodes in the graph.
type AuthMutation struct {
	config
	op               Op
	typ              string
	id               *int
	last_auth_time   *time.Time
	auth_type        *auth.AuthType
	clearedFields    map[string]struct{}
	belong_to        *int
	clearedbelong_to bool
	done             bool
	oldValue         func(context.Context) (*Auth, error)
	predicates       []predicate.Auth
}

var _ ent.Mutation = (*AuthMutation)(nil)

// authOption allows management of the mutation configuration using functional options.
type authOption func(*AuthMutation)

// newAuthMutation creates new mutation for the Auth entity.
func newAuthMutation(c config, op Op, opts ...authOption) *AuthMutation {
	m := &AuthMutation{
		config:        c,
		op:            op,
		typ:           TypeAuth,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAuthID sets the ID field of the mutation.
func withAuthID(id int) authOption {
	return func(m *AuthMutation) {
		var (
			err   error
			once  sync.Once
			value *Auth
		)
		m.oldValue = func(ctx context.Context) (*Auth, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Auth.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAuth sets the old Auth of the mutation.
func withAuth(node *Auth) authOption {
	return func(m *AuthMutation) {
		m.oldValue = func(context.Context) (*Auth, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AuthMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AuthMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AuthMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetLastAuthTime sets the "last_auth_time" field.
func (m *AuthMutation) SetLastAuthTime(t time.Time) {
	m.last_auth_time = &t
}

// LastAuthTime returns the value of the "last_auth_time" field in the mutation.
func (m *AuthMutation) LastAuthTime() (r time.Time, exists bool) {
	v := m.last_auth_time
	if v == nil {
		return
	}
	return *v, true
}

// OldLastAuthTime returns the old "last_auth_time" field's value of the Auth entity.
// If the Auth object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthMutation) OldLastAuthTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldLastAuthTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldLastAuthTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastAuthTime: %w", err)
	}
	return oldValue.LastAuthTime, nil
}

// ResetLastAuthTime resets all changes to the "last_auth_time" field.
func (m *AuthMutation) ResetLastAuthTime() {
	m.last_auth_time = nil
}

// SetAuthType sets the "auth_type" field.
func (m *AuthMutation) SetAuthType(at auth.AuthType) {
	m.auth_type = &at
}

// AuthType returns the value of the "auth_type" field in the mutation.
func (m *AuthMutation) AuthType() (r auth.AuthType, exists bool) {
	v := m.auth_type
	if v == nil {
		return
	}
	return *v, true
}

// OldAuthType returns the old "auth_type" field's value of the Auth entity.
// If the Auth object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthMutation) OldAuthType(ctx context.Context) (v auth.AuthType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAuthType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAuthType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuthType: %w", err)
	}
	return oldValue.AuthType, nil
}

// ResetAuthType resets all changes to the "auth_type" field.
func (m *AuthMutation) ResetAuthType() {
	m.auth_type = nil
}

// SetBelongToID sets the "belong_to" edge to the User entity by id.
func (m *AuthMutation) SetBelongToID(id int) {
	m.belong_to = &id
}

// ClearBelongTo clears the "belong_to" edge to the User entity.
func (m *AuthMutation) ClearBelongTo() {
	m.clearedbelong_to = true
}

// BelongToCleared reports if the "belong_to" edge to the User entity was cleared.
func (m *AuthMutation) BelongToCleared() bool {
	return m.clearedbelong_to
}

// BelongToID returns the "belong_to" edge ID in the mutation.
func (m *AuthMutation) BelongToID() (id int, exists bool) {
	if m.belong_to != nil {
		return *m.belong_to, true
	}
	return
}

// BelongToIDs returns the "belong_to" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BelongToID instead. It exists only for internal usage by the builders.
func (m *AuthMutation) BelongToIDs() (ids []int) {
	if id := m.belong_to; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBelongTo resets all changes to the "belong_to" edge.
func (m *AuthMutation) ResetBelongTo() {
	m.belong_to = nil
	m.clearedbelong_to = false
}

// Where appends a list predicates to the AuthMutation builder.
func (m *AuthMutation) Where(ps ...predicate.Auth) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *AuthMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Auth).
func (m *AuthMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AuthMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.last_auth_time != nil {
		fields = append(fields, auth.FieldLastAuthTime)
	}
	if m.auth_type != nil {
		fields = append(fields, auth.FieldAuthType)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AuthMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case auth.FieldLastAuthTime:
		return m.LastAuthTime()
	case auth.FieldAuthType:
		return m.AuthType()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AuthMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case auth.FieldLastAuthTime:
		return m.OldLastAuthTime(ctx)
	case auth.FieldAuthType:
		return m.OldAuthType(ctx)
	}
	return nil, fmt.Errorf("unknown Auth field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AuthMutation) SetField(name string, value ent.Value) error {
	switch name {
	case auth.FieldLastAuthTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastAuthTime(v)
		return nil
	case auth.FieldAuthType:
		v, ok := value.(auth.AuthType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuthType(v)
		return nil
	}
	return fmt.Errorf("unknown Auth field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AuthMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AuthMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AuthMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Auth numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AuthMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AuthMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AuthMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Auth nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AuthMutation) ResetField(name string) error {
	switch name {
	case auth.FieldLastAuthTime:
		m.ResetLastAuthTime()
		return nil
	case auth.FieldAuthType:
		m.ResetAuthType()
		return nil
	}
	return fmt.Errorf("unknown Auth field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AuthMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.belong_to != nil {
		edges = append(edges, auth.EdgeBelongTo)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AuthMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case auth.EdgeBelongTo:
		if id := m.belong_to; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AuthMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AuthMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AuthMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedbelong_to {
		edges = append(edges, auth.EdgeBelongTo)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AuthMutation) EdgeCleared(name string) bool {
	switch name {
	case auth.EdgeBelongTo:
		return m.clearedbelong_to
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AuthMutation) ClearEdge(name string) error {
	switch name {
	case auth.EdgeBelongTo:
		m.ClearBelongTo()
		return nil
	}
	return fmt.Errorf("unknown Auth unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AuthMutation) ResetEdge(name string) error {
	switch name {
	case auth.EdgeBelongTo:
		m.ResetBelongTo()
		return nil
	}
	return fmt.Errorf("unknown Auth edge %s", name)
}

// JobHistoryMutation represents an operation that mutates the JobHistory nodes in the graph.
type JobHistoryMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	create_time          *time.Time
	date                 *time.Time
	job_entry_leave_type *jobhistory.JobEntryLeaveType
	clearedFields        map[string]struct{}
	create_by            *int
	clearedcreate_by     bool
	belong_to            *int
	clearedbelong_to     bool
	done                 bool
	oldValue             func(context.Context) (*JobHistory, error)
	predicates           []predicate.JobHistory
}

var _ ent.Mutation = (*JobHistoryMutation)(nil)

// jobhistoryOption allows management of the mutation configuration using functional options.
type jobhistoryOption func(*JobHistoryMutation)

// newJobHistoryMutation creates new mutation for the JobHistory entity.
func newJobHistoryMutation(c config, op Op, opts ...jobhistoryOption) *JobHistoryMutation {
	m := &JobHistoryMutation{
		config:        c,
		op:            op,
		typ:           TypeJobHistory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withJobHistoryID sets the ID field of the mutation.
func withJobHistoryID(id int) jobhistoryOption {
	return func(m *JobHistoryMutation) {
		var (
			err   error
			once  sync.Once
			value *JobHistory
		)
		m.oldValue = func(ctx context.Context) (*JobHistory, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().JobHistory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withJobHistory sets the old JobHistory of the mutation.
func withJobHistory(node *JobHistory) jobhistoryOption {
	return func(m *JobHistoryMutation) {
		m.oldValue = func(context.Context) (*JobHistory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m JobHistoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m JobHistoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *JobHistoryMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateByUser sets the "create_by_user" field.
func (m *JobHistoryMutation) SetCreateByUser(i int) {
	m.create_by = &i
}

// CreateByUser returns the value of the "create_by_user" field in the mutation.
func (m *JobHistoryMutation) CreateByUser() (r int, exists bool) {
	v := m.create_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateByUser returns the old "create_by_user" field's value of the JobHistory entity.
// If the JobHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobHistoryMutation) OldCreateByUser(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateByUser is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateByUser requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateByUser: %w", err)
	}
	return oldValue.CreateByUser, nil
}

// ClearCreateByUser clears the value of the "create_by_user" field.
func (m *JobHistoryMutation) ClearCreateByUser() {
	m.create_by = nil
	m.clearedFields[jobhistory.FieldCreateByUser] = struct{}{}
}

// CreateByUserCleared returns if the "create_by_user" field was cleared in this mutation.
func (m *JobHistoryMutation) CreateByUserCleared() bool {
	_, ok := m.clearedFields[jobhistory.FieldCreateByUser]
	return ok
}

// ResetCreateByUser resets all changes to the "create_by_user" field.
func (m *JobHistoryMutation) ResetCreateByUser() {
	m.create_by = nil
	delete(m.clearedFields, jobhistory.FieldCreateByUser)
}

// SetCreateTime sets the "create_time" field.
func (m *JobHistoryMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *JobHistoryMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the JobHistory entity.
// If the JobHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobHistoryMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *JobHistoryMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetDate sets the "date" field.
func (m *JobHistoryMutation) SetDate(t time.Time) {
	m.date = &t
}

// Date returns the value of the "date" field in the mutation.
func (m *JobHistoryMutation) Date() (r time.Time, exists bool) {
	v := m.date
	if v == nil {
		return
	}
	return *v, true
}

// OldDate returns the old "date" field's value of the JobHistory entity.
// If the JobHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobHistoryMutation) OldDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDate: %w", err)
	}
	return oldValue.Date, nil
}

// ResetDate resets all changes to the "date" field.
func (m *JobHistoryMutation) ResetDate() {
	m.date = nil
}

// SetJobEntryLeaveType sets the "job_entry_leave_type" field.
func (m *JobHistoryMutation) SetJobEntryLeaveType(jelt jobhistory.JobEntryLeaveType) {
	m.job_entry_leave_type = &jelt
}

// JobEntryLeaveType returns the value of the "job_entry_leave_type" field in the mutation.
func (m *JobHistoryMutation) JobEntryLeaveType() (r jobhistory.JobEntryLeaveType, exists bool) {
	v := m.job_entry_leave_type
	if v == nil {
		return
	}
	return *v, true
}

// OldJobEntryLeaveType returns the old "job_entry_leave_type" field's value of the JobHistory entity.
// If the JobHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobHistoryMutation) OldJobEntryLeaveType(ctx context.Context) (v jobhistory.JobEntryLeaveType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldJobEntryLeaveType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldJobEntryLeaveType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldJobEntryLeaveType: %w", err)
	}
	return oldValue.JobEntryLeaveType, nil
}

// ResetJobEntryLeaveType resets all changes to the "job_entry_leave_type" field.
func (m *JobHistoryMutation) ResetJobEntryLeaveType() {
	m.job_entry_leave_type = nil
}

// SetCreateByID sets the "create_by" edge to the User entity by id.
func (m *JobHistoryMutation) SetCreateByID(id int) {
	m.create_by = &id
}

// ClearCreateBy clears the "create_by" edge to the User entity.
func (m *JobHistoryMutation) ClearCreateBy() {
	m.clearedcreate_by = true
}

// CreateByCleared reports if the "create_by" edge to the User entity was cleared.
func (m *JobHistoryMutation) CreateByCleared() bool {
	return m.CreateByUserCleared() || m.clearedcreate_by
}

// CreateByID returns the "create_by" edge ID in the mutation.
func (m *JobHistoryMutation) CreateByID() (id int, exists bool) {
	if m.create_by != nil {
		return *m.create_by, true
	}
	return
}

// CreateByIDs returns the "create_by" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CreateByID instead. It exists only for internal usage by the builders.
func (m *JobHistoryMutation) CreateByIDs() (ids []int) {
	if id := m.create_by; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCreateBy resets all changes to the "create_by" edge.
func (m *JobHistoryMutation) ResetCreateBy() {
	m.create_by = nil
	m.clearedcreate_by = false
}

// SetBelongToID sets the "belong_to" edge to the User entity by id.
func (m *JobHistoryMutation) SetBelongToID(id int) {
	m.belong_to = &id
}

// ClearBelongTo clears the "belong_to" edge to the User entity.
func (m *JobHistoryMutation) ClearBelongTo() {
	m.clearedbelong_to = true
}

// BelongToCleared reports if the "belong_to" edge to the User entity was cleared.
func (m *JobHistoryMutation) BelongToCleared() bool {
	return m.clearedbelong_to
}

// BelongToID returns the "belong_to" edge ID in the mutation.
func (m *JobHistoryMutation) BelongToID() (id int, exists bool) {
	if m.belong_to != nil {
		return *m.belong_to, true
	}
	return
}

// BelongToIDs returns the "belong_to" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BelongToID instead. It exists only for internal usage by the builders.
func (m *JobHistoryMutation) BelongToIDs() (ids []int) {
	if id := m.belong_to; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBelongTo resets all changes to the "belong_to" edge.
func (m *JobHistoryMutation) ResetBelongTo() {
	m.belong_to = nil
	m.clearedbelong_to = false
}

// Where appends a list predicates to the JobHistoryMutation builder.
func (m *JobHistoryMutation) Where(ps ...predicate.JobHistory) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *JobHistoryMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (JobHistory).
func (m *JobHistoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *JobHistoryMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.create_by != nil {
		fields = append(fields, jobhistory.FieldCreateByUser)
	}
	if m.create_time != nil {
		fields = append(fields, jobhistory.FieldCreateTime)
	}
	if m.date != nil {
		fields = append(fields, jobhistory.FieldDate)
	}
	if m.job_entry_leave_type != nil {
		fields = append(fields, jobhistory.FieldJobEntryLeaveType)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *JobHistoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case jobhistory.FieldCreateByUser:
		return m.CreateByUser()
	case jobhistory.FieldCreateTime:
		return m.CreateTime()
	case jobhistory.FieldDate:
		return m.Date()
	case jobhistory.FieldJobEntryLeaveType:
		return m.JobEntryLeaveType()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *JobHistoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case jobhistory.FieldCreateByUser:
		return m.OldCreateByUser(ctx)
	case jobhistory.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case jobhistory.FieldDate:
		return m.OldDate(ctx)
	case jobhistory.FieldJobEntryLeaveType:
		return m.OldJobEntryLeaveType(ctx)
	}
	return nil, fmt.Errorf("unknown JobHistory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *JobHistoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case jobhistory.FieldCreateByUser:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateByUser(v)
		return nil
	case jobhistory.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case jobhistory.FieldDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDate(v)
		return nil
	case jobhistory.FieldJobEntryLeaveType:
		v, ok := value.(jobhistory.JobEntryLeaveType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetJobEntryLeaveType(v)
		return nil
	}
	return fmt.Errorf("unknown JobHistory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *JobHistoryMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *JobHistoryMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *JobHistoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown JobHistory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *JobHistoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(jobhistory.FieldCreateByUser) {
		fields = append(fields, jobhistory.FieldCreateByUser)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *JobHistoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *JobHistoryMutation) ClearField(name string) error {
	switch name {
	case jobhistory.FieldCreateByUser:
		m.ClearCreateByUser()
		return nil
	}
	return fmt.Errorf("unknown JobHistory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *JobHistoryMutation) ResetField(name string) error {
	switch name {
	case jobhistory.FieldCreateByUser:
		m.ResetCreateByUser()
		return nil
	case jobhistory.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case jobhistory.FieldDate:
		m.ResetDate()
		return nil
	case jobhistory.FieldJobEntryLeaveType:
		m.ResetJobEntryLeaveType()
		return nil
	}
	return fmt.Errorf("unknown JobHistory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *JobHistoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.create_by != nil {
		edges = append(edges, jobhistory.EdgeCreateBy)
	}
	if m.belong_to != nil {
		edges = append(edges, jobhistory.EdgeBelongTo)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *JobHistoryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case jobhistory.EdgeCreateBy:
		if id := m.create_by; id != nil {
			return []ent.Value{*id}
		}
	case jobhistory.EdgeBelongTo:
		if id := m.belong_to; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *JobHistoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *JobHistoryMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *JobHistoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedcreate_by {
		edges = append(edges, jobhistory.EdgeCreateBy)
	}
	if m.clearedbelong_to {
		edges = append(edges, jobhistory.EdgeBelongTo)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *JobHistoryMutation) EdgeCleared(name string) bool {
	switch name {
	case jobhistory.EdgeCreateBy:
		return m.clearedcreate_by
	case jobhistory.EdgeBelongTo:
		return m.clearedbelong_to
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *JobHistoryMutation) ClearEdge(name string) error {
	switch name {
	case jobhistory.EdgeCreateBy:
		m.ClearCreateBy()
		return nil
	case jobhistory.EdgeBelongTo:
		m.ClearBelongTo()
		return nil
	}
	return fmt.Errorf("unknown JobHistory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *JobHistoryMutation) ResetEdge(name string) error {
	switch name {
	case jobhistory.EdgeCreateBy:
		m.ResetCreateBy()
		return nil
	case jobhistory.EdgeBelongTo:
		m.ResetBelongTo()
		return nil
	}
	return fmt.Errorf("unknown JobHistory edge %s", name)
}

// OrgUnitMutation represents an operation that mutates the OrgUnit nodes in the graph.
type OrgUnitMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	create_time        *time.Time
	update_time        *time.Time
	name               *string
	duty               *string
	clearedFields      map[string]struct{}
	create_by          *int
	clearedcreate_by   bool
	update_by          *int
	clearedupdate_by   bool
	members            map[int]struct{}
	removedmembers     map[int]struct{}
	clearedmembers     bool
	positions          map[int]struct{}
	removedpositions   map[int]struct{}
	clearedpositions   bool
	supUnit            *int
	clearedsupUnit     bool
	subUnits           map[int]struct{}
	removedsubUnits    map[int]struct{}
	clearedsubUnits    bool
	belongToOrg        *int
	clearedbelongToOrg bool
	done               bool
	oldValue           func(context.Context) (*OrgUnit, error)
	predicates         []predicate.OrgUnit
}

var _ ent.Mutation = (*OrgUnitMutation)(nil)

// orgunitOption allows management of the mutation configuration using functional options.
type orgunitOption func(*OrgUnitMutation)

// newOrgUnitMutation creates new mutation for the OrgUnit entity.
func newOrgUnitMutation(c config, op Op, opts ...orgunitOption) *OrgUnitMutation {
	m := &OrgUnitMutation{
		config:        c,
		op:            op,
		typ:           TypeOrgUnit,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOrgUnitID sets the ID field of the mutation.
func withOrgUnitID(id int) orgunitOption {
	return func(m *OrgUnitMutation) {
		var (
			err   error
			once  sync.Once
			value *OrgUnit
		)
		m.oldValue = func(ctx context.Context) (*OrgUnit, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OrgUnit.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOrgUnit sets the old OrgUnit of the mutation.
func withOrgUnit(node *OrgUnit) orgunitOption {
	return func(m *OrgUnitMutation) {
		m.oldValue = func(context.Context) (*OrgUnit, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OrgUnitMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OrgUnitMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OrgUnitMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateByUser sets the "create_by_user" field.
func (m *OrgUnitMutation) SetCreateByUser(i int) {
	m.create_by = &i
}

// CreateByUser returns the value of the "create_by_user" field in the mutation.
func (m *OrgUnitMutation) CreateByUser() (r int, exists bool) {
	v := m.create_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateByUser returns the old "create_by_user" field's value of the OrgUnit entity.
// If the OrgUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrgUnitMutation) OldCreateByUser(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateByUser is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateByUser requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateByUser: %w", err)
	}
	return oldValue.CreateByUser, nil
}

// ClearCreateByUser clears the value of the "create_by_user" field.
func (m *OrgUnitMutation) ClearCreateByUser() {
	m.create_by = nil
	m.clearedFields[orgunit.FieldCreateByUser] = struct{}{}
}

// CreateByUserCleared returns if the "create_by_user" field was cleared in this mutation.
func (m *OrgUnitMutation) CreateByUserCleared() bool {
	_, ok := m.clearedFields[orgunit.FieldCreateByUser]
	return ok
}

// ResetCreateByUser resets all changes to the "create_by_user" field.
func (m *OrgUnitMutation) ResetCreateByUser() {
	m.create_by = nil
	delete(m.clearedFields, orgunit.FieldCreateByUser)
}

// SetUpdateByUser sets the "update_by_user" field.
func (m *OrgUnitMutation) SetUpdateByUser(i int) {
	m.update_by = &i
}

// UpdateByUser returns the value of the "update_by_user" field in the mutation.
func (m *OrgUnitMutation) UpdateByUser() (r int, exists bool) {
	v := m.update_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateByUser returns the old "update_by_user" field's value of the OrgUnit entity.
// If the OrgUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrgUnitMutation) OldUpdateByUser(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateByUser is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateByUser requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateByUser: %w", err)
	}
	return oldValue.UpdateByUser, nil
}

// ClearUpdateByUser clears the value of the "update_by_user" field.
func (m *OrgUnitMutation) ClearUpdateByUser() {
	m.update_by = nil
	m.clearedFields[orgunit.FieldUpdateByUser] = struct{}{}
}

// UpdateByUserCleared returns if the "update_by_user" field was cleared in this mutation.
func (m *OrgUnitMutation) UpdateByUserCleared() bool {
	_, ok := m.clearedFields[orgunit.FieldUpdateByUser]
	return ok
}

// ResetUpdateByUser resets all changes to the "update_by_user" field.
func (m *OrgUnitMutation) ResetUpdateByUser() {
	m.update_by = nil
	delete(m.clearedFields, orgunit.FieldUpdateByUser)
}

// SetCreateTime sets the "create_time" field.
func (m *OrgUnitMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *OrgUnitMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the OrgUnit entity.
// If the OrgUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrgUnitMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *OrgUnitMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *OrgUnitMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *OrgUnitMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the OrgUnit entity.
// If the OrgUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrgUnitMutation) OldUpdateTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ClearUpdateTime clears the value of the "update_time" field.
func (m *OrgUnitMutation) ClearUpdateTime() {
	m.update_time = nil
	m.clearedFields[orgunit.FieldUpdateTime] = struct{}{}
}

// UpdateTimeCleared returns if the "update_time" field was cleared in this mutation.
func (m *OrgUnitMutation) UpdateTimeCleared() bool {
	_, ok := m.clearedFields[orgunit.FieldUpdateTime]
	return ok
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *OrgUnitMutation) ResetUpdateTime() {
	m.update_time = nil
	delete(m.clearedFields, orgunit.FieldUpdateTime)
}

// SetName sets the "name" field.
func (m *OrgUnitMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *OrgUnitMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the OrgUnit entity.
// If the OrgUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrgUnitMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *OrgUnitMutation) ResetName() {
	m.name = nil
}

// SetDuty sets the "duty" field.
func (m *OrgUnitMutation) SetDuty(s string) {
	m.duty = &s
}

// Duty returns the value of the "duty" field in the mutation.
func (m *OrgUnitMutation) Duty() (r string, exists bool) {
	v := m.duty
	if v == nil {
		return
	}
	return *v, true
}

// OldDuty returns the old "duty" field's value of the OrgUnit entity.
// If the OrgUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrgUnitMutation) OldDuty(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDuty is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDuty requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDuty: %w", err)
	}
	return oldValue.Duty, nil
}

// ClearDuty clears the value of the "duty" field.
func (m *OrgUnitMutation) ClearDuty() {
	m.duty = nil
	m.clearedFields[orgunit.FieldDuty] = struct{}{}
}

// DutyCleared returns if the "duty" field was cleared in this mutation.
func (m *OrgUnitMutation) DutyCleared() bool {
	_, ok := m.clearedFields[orgunit.FieldDuty]
	return ok
}

// ResetDuty resets all changes to the "duty" field.
func (m *OrgUnitMutation) ResetDuty() {
	m.duty = nil
	delete(m.clearedFields, orgunit.FieldDuty)
}

// SetCreateByID sets the "create_by" edge to the User entity by id.
func (m *OrgUnitMutation) SetCreateByID(id int) {
	m.create_by = &id
}

// ClearCreateBy clears the "create_by" edge to the User entity.
func (m *OrgUnitMutation) ClearCreateBy() {
	m.clearedcreate_by = true
}

// CreateByCleared reports if the "create_by" edge to the User entity was cleared.
func (m *OrgUnitMutation) CreateByCleared() bool {
	return m.CreateByUserCleared() || m.clearedcreate_by
}

// CreateByID returns the "create_by" edge ID in the mutation.
func (m *OrgUnitMutation) CreateByID() (id int, exists bool) {
	if m.create_by != nil {
		return *m.create_by, true
	}
	return
}

// CreateByIDs returns the "create_by" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CreateByID instead. It exists only for internal usage by the builders.
func (m *OrgUnitMutation) CreateByIDs() (ids []int) {
	if id := m.create_by; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCreateBy resets all changes to the "create_by" edge.
func (m *OrgUnitMutation) ResetCreateBy() {
	m.create_by = nil
	m.clearedcreate_by = false
}

// SetUpdateByID sets the "update_by" edge to the User entity by id.
func (m *OrgUnitMutation) SetUpdateByID(id int) {
	m.update_by = &id
}

// ClearUpdateBy clears the "update_by" edge to the User entity.
func (m *OrgUnitMutation) ClearUpdateBy() {
	m.clearedupdate_by = true
}

// UpdateByCleared reports if the "update_by" edge to the User entity was cleared.
func (m *OrgUnitMutation) UpdateByCleared() bool {
	return m.UpdateByUserCleared() || m.clearedupdate_by
}

// UpdateByID returns the "update_by" edge ID in the mutation.
func (m *OrgUnitMutation) UpdateByID() (id int, exists bool) {
	if m.update_by != nil {
		return *m.update_by, true
	}
	return
}

// UpdateByIDs returns the "update_by" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UpdateByID instead. It exists only for internal usage by the builders.
func (m *OrgUnitMutation) UpdateByIDs() (ids []int) {
	if id := m.update_by; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUpdateBy resets all changes to the "update_by" edge.
func (m *OrgUnitMutation) ResetUpdateBy() {
	m.update_by = nil
	m.clearedupdate_by = false
}

// AddMemberIDs adds the "members" edge to the OrgUnitMember entity by ids.
func (m *OrgUnitMutation) AddMemberIDs(ids ...int) {
	if m.members == nil {
		m.members = make(map[int]struct{})
	}
	for i := range ids {
		m.members[ids[i]] = struct{}{}
	}
}

// ClearMembers clears the "members" edge to the OrgUnitMember entity.
func (m *OrgUnitMutation) ClearMembers() {
	m.clearedmembers = true
}

// MembersCleared reports if the "members" edge to the OrgUnitMember entity was cleared.
func (m *OrgUnitMutation) MembersCleared() bool {
	return m.clearedmembers
}

// RemoveMemberIDs removes the "members" edge to the OrgUnitMember entity by IDs.
func (m *OrgUnitMutation) RemoveMemberIDs(ids ...int) {
	if m.removedmembers == nil {
		m.removedmembers = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.members, ids[i])
		m.removedmembers[ids[i]] = struct{}{}
	}
}

// RemovedMembers returns the removed IDs of the "members" edge to the OrgUnitMember entity.
func (m *OrgUnitMutation) RemovedMembersIDs() (ids []int) {
	for id := range m.removedmembers {
		ids = append(ids, id)
	}
	return
}

// MembersIDs returns the "members" edge IDs in the mutation.
func (m *OrgUnitMutation) MembersIDs() (ids []int) {
	for id := range m.members {
		ids = append(ids, id)
	}
	return
}

// ResetMembers resets all changes to the "members" edge.
func (m *OrgUnitMutation) ResetMembers() {
	m.members = nil
	m.clearedmembers = false
	m.removedmembers = nil
}

// AddPositionIDs adds the "positions" edge to the OrgUnitPosition entity by ids.
func (m *OrgUnitMutation) AddPositionIDs(ids ...int) {
	if m.positions == nil {
		m.positions = make(map[int]struct{})
	}
	for i := range ids {
		m.positions[ids[i]] = struct{}{}
	}
}

// ClearPositions clears the "positions" edge to the OrgUnitPosition entity.
func (m *OrgUnitMutation) ClearPositions() {
	m.clearedpositions = true
}

// PositionsCleared reports if the "positions" edge to the OrgUnitPosition entity was cleared.
func (m *OrgUnitMutation) PositionsCleared() bool {
	return m.clearedpositions
}

// RemovePositionIDs removes the "positions" edge to the OrgUnitPosition entity by IDs.
func (m *OrgUnitMutation) RemovePositionIDs(ids ...int) {
	if m.removedpositions == nil {
		m.removedpositions = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.positions, ids[i])
		m.removedpositions[ids[i]] = struct{}{}
	}
}

// RemovedPositions returns the removed IDs of the "positions" edge to the OrgUnitPosition entity.
func (m *OrgUnitMutation) RemovedPositionsIDs() (ids []int) {
	for id := range m.removedpositions {
		ids = append(ids, id)
	}
	return
}

// PositionsIDs returns the "positions" edge IDs in the mutation.
func (m *OrgUnitMutation) PositionsIDs() (ids []int) {
	for id := range m.positions {
		ids = append(ids, id)
	}
	return
}

// ResetPositions resets all changes to the "positions" edge.
func (m *OrgUnitMutation) ResetPositions() {
	m.positions = nil
	m.clearedpositions = false
	m.removedpositions = nil
}

// SetSupUnitID sets the "supUnit" edge to the OrgUnit entity by id.
func (m *OrgUnitMutation) SetSupUnitID(id int) {
	m.supUnit = &id
}

// ClearSupUnit clears the "supUnit" edge to the OrgUnit entity.
func (m *OrgUnitMutation) ClearSupUnit() {
	m.clearedsupUnit = true
}

// SupUnitCleared reports if the "supUnit" edge to the OrgUnit entity was cleared.
func (m *OrgUnitMutation) SupUnitCleared() bool {
	return m.clearedsupUnit
}

// SupUnitID returns the "supUnit" edge ID in the mutation.
func (m *OrgUnitMutation) SupUnitID() (id int, exists bool) {
	if m.supUnit != nil {
		return *m.supUnit, true
	}
	return
}

// SupUnitIDs returns the "supUnit" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SupUnitID instead. It exists only for internal usage by the builders.
func (m *OrgUnitMutation) SupUnitIDs() (ids []int) {
	if id := m.supUnit; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSupUnit resets all changes to the "supUnit" edge.
func (m *OrgUnitMutation) ResetSupUnit() {
	m.supUnit = nil
	m.clearedsupUnit = false
}

// AddSubUnitIDs adds the "subUnits" edge to the OrgUnit entity by ids.
func (m *OrgUnitMutation) AddSubUnitIDs(ids ...int) {
	if m.subUnits == nil {
		m.subUnits = make(map[int]struct{})
	}
	for i := range ids {
		m.subUnits[ids[i]] = struct{}{}
	}
}

// ClearSubUnits clears the "subUnits" edge to the OrgUnit entity.
func (m *OrgUnitMutation) ClearSubUnits() {
	m.clearedsubUnits = true
}

// SubUnitsCleared reports if the "subUnits" edge to the OrgUnit entity was cleared.
func (m *OrgUnitMutation) SubUnitsCleared() bool {
	return m.clearedsubUnits
}

// RemoveSubUnitIDs removes the "subUnits" edge to the OrgUnit entity by IDs.
func (m *OrgUnitMutation) RemoveSubUnitIDs(ids ...int) {
	if m.removedsubUnits == nil {
		m.removedsubUnits = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.subUnits, ids[i])
		m.removedsubUnits[ids[i]] = struct{}{}
	}
}

// RemovedSubUnits returns the removed IDs of the "subUnits" edge to the OrgUnit entity.
func (m *OrgUnitMutation) RemovedSubUnitsIDs() (ids []int) {
	for id := range m.removedsubUnits {
		ids = append(ids, id)
	}
	return
}

// SubUnitsIDs returns the "subUnits" edge IDs in the mutation.
func (m *OrgUnitMutation) SubUnitsIDs() (ids []int) {
	for id := range m.subUnits {
		ids = append(ids, id)
	}
	return
}

// ResetSubUnits resets all changes to the "subUnits" edge.
func (m *OrgUnitMutation) ResetSubUnits() {
	m.subUnits = nil
	m.clearedsubUnits = false
	m.removedsubUnits = nil
}

// SetBelongToOrgID sets the "belongToOrg" edge to the Organization entity by id.
func (m *OrgUnitMutation) SetBelongToOrgID(id int) {
	m.belongToOrg = &id
}

// ClearBelongToOrg clears the "belongToOrg" edge to the Organization entity.
func (m *OrgUnitMutation) ClearBelongToOrg() {
	m.clearedbelongToOrg = true
}

// BelongToOrgCleared reports if the "belongToOrg" edge to the Organization entity was cleared.
func (m *OrgUnitMutation) BelongToOrgCleared() bool {
	return m.clearedbelongToOrg
}

// BelongToOrgID returns the "belongToOrg" edge ID in the mutation.
func (m *OrgUnitMutation) BelongToOrgID() (id int, exists bool) {
	if m.belongToOrg != nil {
		return *m.belongToOrg, true
	}
	return
}

// BelongToOrgIDs returns the "belongToOrg" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BelongToOrgID instead. It exists only for internal usage by the builders.
func (m *OrgUnitMutation) BelongToOrgIDs() (ids []int) {
	if id := m.belongToOrg; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBelongToOrg resets all changes to the "belongToOrg" edge.
func (m *OrgUnitMutation) ResetBelongToOrg() {
	m.belongToOrg = nil
	m.clearedbelongToOrg = false
}

// Where appends a list predicates to the OrgUnitMutation builder.
func (m *OrgUnitMutation) Where(ps ...predicate.OrgUnit) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *OrgUnitMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (OrgUnit).
func (m *OrgUnitMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OrgUnitMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.create_by != nil {
		fields = append(fields, orgunit.FieldCreateByUser)
	}
	if m.update_by != nil {
		fields = append(fields, orgunit.FieldUpdateByUser)
	}
	if m.create_time != nil {
		fields = append(fields, orgunit.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, orgunit.FieldUpdateTime)
	}
	if m.name != nil {
		fields = append(fields, orgunit.FieldName)
	}
	if m.duty != nil {
		fields = append(fields, orgunit.FieldDuty)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OrgUnitMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case orgunit.FieldCreateByUser:
		return m.CreateByUser()
	case orgunit.FieldUpdateByUser:
		return m.UpdateByUser()
	case orgunit.FieldCreateTime:
		return m.CreateTime()
	case orgunit.FieldUpdateTime:
		return m.UpdateTime()
	case orgunit.FieldName:
		return m.Name()
	case orgunit.FieldDuty:
		return m.Duty()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OrgUnitMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case orgunit.FieldCreateByUser:
		return m.OldCreateByUser(ctx)
	case orgunit.FieldUpdateByUser:
		return m.OldUpdateByUser(ctx)
	case orgunit.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case orgunit.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case orgunit.FieldName:
		return m.OldName(ctx)
	case orgunit.FieldDuty:
		return m.OldDuty(ctx)
	}
	return nil, fmt.Errorf("unknown OrgUnit field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrgUnitMutation) SetField(name string, value ent.Value) error {
	switch name {
	case orgunit.FieldCreateByUser:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateByUser(v)
		return nil
	case orgunit.FieldUpdateByUser:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateByUser(v)
		return nil
	case orgunit.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case orgunit.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case orgunit.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case orgunit.FieldDuty:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDuty(v)
		return nil
	}
	return fmt.Errorf("unknown OrgUnit field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OrgUnitMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OrgUnitMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrgUnitMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown OrgUnit numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OrgUnitMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(orgunit.FieldCreateByUser) {
		fields = append(fields, orgunit.FieldCreateByUser)
	}
	if m.FieldCleared(orgunit.FieldUpdateByUser) {
		fields = append(fields, orgunit.FieldUpdateByUser)
	}
	if m.FieldCleared(orgunit.FieldUpdateTime) {
		fields = append(fields, orgunit.FieldUpdateTime)
	}
	if m.FieldCleared(orgunit.FieldDuty) {
		fields = append(fields, orgunit.FieldDuty)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OrgUnitMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OrgUnitMutation) ClearField(name string) error {
	switch name {
	case orgunit.FieldCreateByUser:
		m.ClearCreateByUser()
		return nil
	case orgunit.FieldUpdateByUser:
		m.ClearUpdateByUser()
		return nil
	case orgunit.FieldUpdateTime:
		m.ClearUpdateTime()
		return nil
	case orgunit.FieldDuty:
		m.ClearDuty()
		return nil
	}
	return fmt.Errorf("unknown OrgUnit nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OrgUnitMutation) ResetField(name string) error {
	switch name {
	case orgunit.FieldCreateByUser:
		m.ResetCreateByUser()
		return nil
	case orgunit.FieldUpdateByUser:
		m.ResetUpdateByUser()
		return nil
	case orgunit.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case orgunit.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case orgunit.FieldName:
		m.ResetName()
		return nil
	case orgunit.FieldDuty:
		m.ResetDuty()
		return nil
	}
	return fmt.Errorf("unknown OrgUnit field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OrgUnitMutation) AddedEdges() []string {
	edges := make([]string, 0, 7)
	if m.create_by != nil {
		edges = append(edges, orgunit.EdgeCreateBy)
	}
	if m.update_by != nil {
		edges = append(edges, orgunit.EdgeUpdateBy)
	}
	if m.members != nil {
		edges = append(edges, orgunit.EdgeMembers)
	}
	if m.positions != nil {
		edges = append(edges, orgunit.EdgePositions)
	}
	if m.supUnit != nil {
		edges = append(edges, orgunit.EdgeSupUnit)
	}
	if m.subUnits != nil {
		edges = append(edges, orgunit.EdgeSubUnits)
	}
	if m.belongToOrg != nil {
		edges = append(edges, orgunit.EdgeBelongToOrg)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OrgUnitMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case orgunit.EdgeCreateBy:
		if id := m.create_by; id != nil {
			return []ent.Value{*id}
		}
	case orgunit.EdgeUpdateBy:
		if id := m.update_by; id != nil {
			return []ent.Value{*id}
		}
	case orgunit.EdgeMembers:
		ids := make([]ent.Value, 0, len(m.members))
		for id := range m.members {
			ids = append(ids, id)
		}
		return ids
	case orgunit.EdgePositions:
		ids := make([]ent.Value, 0, len(m.positions))
		for id := range m.positions {
			ids = append(ids, id)
		}
		return ids
	case orgunit.EdgeSupUnit:
		if id := m.supUnit; id != nil {
			return []ent.Value{*id}
		}
	case orgunit.EdgeSubUnits:
		ids := make([]ent.Value, 0, len(m.subUnits))
		for id := range m.subUnits {
			ids = append(ids, id)
		}
		return ids
	case orgunit.EdgeBelongToOrg:
		if id := m.belongToOrg; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OrgUnitMutation) RemovedEdges() []string {
	edges := make([]string, 0, 7)
	if m.removedmembers != nil {
		edges = append(edges, orgunit.EdgeMembers)
	}
	if m.removedpositions != nil {
		edges = append(edges, orgunit.EdgePositions)
	}
	if m.removedsubUnits != nil {
		edges = append(edges, orgunit.EdgeSubUnits)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OrgUnitMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case orgunit.EdgeMembers:
		ids := make([]ent.Value, 0, len(m.removedmembers))
		for id := range m.removedmembers {
			ids = append(ids, id)
		}
		return ids
	case orgunit.EdgePositions:
		ids := make([]ent.Value, 0, len(m.removedpositions))
		for id := range m.removedpositions {
			ids = append(ids, id)
		}
		return ids
	case orgunit.EdgeSubUnits:
		ids := make([]ent.Value, 0, len(m.removedsubUnits))
		for id := range m.removedsubUnits {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OrgUnitMutation) ClearedEdges() []string {
	edges := make([]string, 0, 7)
	if m.clearedcreate_by {
		edges = append(edges, orgunit.EdgeCreateBy)
	}
	if m.clearedupdate_by {
		edges = append(edges, orgunit.EdgeUpdateBy)
	}
	if m.clearedmembers {
		edges = append(edges, orgunit.EdgeMembers)
	}
	if m.clearedpositions {
		edges = append(edges, orgunit.EdgePositions)
	}
	if m.clearedsupUnit {
		edges = append(edges, orgunit.EdgeSupUnit)
	}
	if m.clearedsubUnits {
		edges = append(edges, orgunit.EdgeSubUnits)
	}
	if m.clearedbelongToOrg {
		edges = append(edges, orgunit.EdgeBelongToOrg)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OrgUnitMutation) EdgeCleared(name string) bool {
	switch name {
	case orgunit.EdgeCreateBy:
		return m.clearedcreate_by
	case orgunit.EdgeUpdateBy:
		return m.clearedupdate_by
	case orgunit.EdgeMembers:
		return m.clearedmembers
	case orgunit.EdgePositions:
		return m.clearedpositions
	case orgunit.EdgeSupUnit:
		return m.clearedsupUnit
	case orgunit.EdgeSubUnits:
		return m.clearedsubUnits
	case orgunit.EdgeBelongToOrg:
		return m.clearedbelongToOrg
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OrgUnitMutation) ClearEdge(name string) error {
	switch name {
	case orgunit.EdgeCreateBy:
		m.ClearCreateBy()
		return nil
	case orgunit.EdgeUpdateBy:
		m.ClearUpdateBy()
		return nil
	case orgunit.EdgeSupUnit:
		m.ClearSupUnit()
		return nil
	case orgunit.EdgeBelongToOrg:
		m.ClearBelongToOrg()
		return nil
	}
	return fmt.Errorf("unknown OrgUnit unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OrgUnitMutation) ResetEdge(name string) error {
	switch name {
	case orgunit.EdgeCreateBy:
		m.ResetCreateBy()
		return nil
	case orgunit.EdgeUpdateBy:
		m.ResetUpdateBy()
		return nil
	case orgunit.EdgeMembers:
		m.ResetMembers()
		return nil
	case orgunit.EdgePositions:
		m.ResetPositions()
		return nil
	case orgunit.EdgeSupUnit:
		m.ResetSupUnit()
		return nil
	case orgunit.EdgeSubUnits:
		m.ResetSubUnits()
		return nil
	case orgunit.EdgeBelongToOrg:
		m.ResetBelongToOrg()
		return nil
	}
	return fmt.Errorf("unknown OrgUnit edge %s", name)
}

// OrgUnitMemberMutation represents an operation that mutates the OrgUnitMember nodes in the graph.
type OrgUnitMemberMutation struct {
	config
	op                     Op
	typ                    string
	id                     *int
	create_time            *time.Time
	update_time            *time.Time
	is_additional          *bool
	clearedFields          map[string]struct{}
	create_by              *int
	clearedcreate_by       bool
	update_by              *int
	clearedupdate_by       bool
	user                   *int
	cleareduser            bool
	position               *int
	clearedposition        bool
	belongToOrgUnit        *int
	clearedbelongToOrgUnit bool
	done                   bool
	oldValue               func(context.Context) (*OrgUnitMember, error)
	predicates             []predicate.OrgUnitMember
}

var _ ent.Mutation = (*OrgUnitMemberMutation)(nil)

// orgunitmemberOption allows management of the mutation configuration using functional options.
type orgunitmemberOption func(*OrgUnitMemberMutation)

// newOrgUnitMemberMutation creates new mutation for the OrgUnitMember entity.
func newOrgUnitMemberMutation(c config, op Op, opts ...orgunitmemberOption) *OrgUnitMemberMutation {
	m := &OrgUnitMemberMutation{
		config:        c,
		op:            op,
		typ:           TypeOrgUnitMember,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOrgUnitMemberID sets the ID field of the mutation.
func withOrgUnitMemberID(id int) orgunitmemberOption {
	return func(m *OrgUnitMemberMutation) {
		var (
			err   error
			once  sync.Once
			value *OrgUnitMember
		)
		m.oldValue = func(ctx context.Context) (*OrgUnitMember, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OrgUnitMember.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOrgUnitMember sets the old OrgUnitMember of the mutation.
func withOrgUnitMember(node *OrgUnitMember) orgunitmemberOption {
	return func(m *OrgUnitMemberMutation) {
		m.oldValue = func(context.Context) (*OrgUnitMember, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OrgUnitMemberMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OrgUnitMemberMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OrgUnitMemberMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateByUser sets the "create_by_user" field.
func (m *OrgUnitMemberMutation) SetCreateByUser(i int) {
	m.create_by = &i
}

// CreateByUser returns the value of the "create_by_user" field in the mutation.
func (m *OrgUnitMemberMutation) CreateByUser() (r int, exists bool) {
	v := m.create_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateByUser returns the old "create_by_user" field's value of the OrgUnitMember entity.
// If the OrgUnitMember object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrgUnitMemberMutation) OldCreateByUser(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateByUser is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateByUser requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateByUser: %w", err)
	}
	return oldValue.CreateByUser, nil
}

// ClearCreateByUser clears the value of the "create_by_user" field.
func (m *OrgUnitMemberMutation) ClearCreateByUser() {
	m.create_by = nil
	m.clearedFields[orgunitmember.FieldCreateByUser] = struct{}{}
}

// CreateByUserCleared returns if the "create_by_user" field was cleared in this mutation.
func (m *OrgUnitMemberMutation) CreateByUserCleared() bool {
	_, ok := m.clearedFields[orgunitmember.FieldCreateByUser]
	return ok
}

// ResetCreateByUser resets all changes to the "create_by_user" field.
func (m *OrgUnitMemberMutation) ResetCreateByUser() {
	m.create_by = nil
	delete(m.clearedFields, orgunitmember.FieldCreateByUser)
}

// SetUpdateByUser sets the "update_by_user" field.
func (m *OrgUnitMemberMutation) SetUpdateByUser(i int) {
	m.update_by = &i
}

// UpdateByUser returns the value of the "update_by_user" field in the mutation.
func (m *OrgUnitMemberMutation) UpdateByUser() (r int, exists bool) {
	v := m.update_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateByUser returns the old "update_by_user" field's value of the OrgUnitMember entity.
// If the OrgUnitMember object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrgUnitMemberMutation) OldUpdateByUser(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateByUser is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateByUser requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateByUser: %w", err)
	}
	return oldValue.UpdateByUser, nil
}

// ClearUpdateByUser clears the value of the "update_by_user" field.
func (m *OrgUnitMemberMutation) ClearUpdateByUser() {
	m.update_by = nil
	m.clearedFields[orgunitmember.FieldUpdateByUser] = struct{}{}
}

// UpdateByUserCleared returns if the "update_by_user" field was cleared in this mutation.
func (m *OrgUnitMemberMutation) UpdateByUserCleared() bool {
	_, ok := m.clearedFields[orgunitmember.FieldUpdateByUser]
	return ok
}

// ResetUpdateByUser resets all changes to the "update_by_user" field.
func (m *OrgUnitMemberMutation) ResetUpdateByUser() {
	m.update_by = nil
	delete(m.clearedFields, orgunitmember.FieldUpdateByUser)
}

// SetCreateTime sets the "create_time" field.
func (m *OrgUnitMemberMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *OrgUnitMemberMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the OrgUnitMember entity.
// If the OrgUnitMember object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrgUnitMemberMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *OrgUnitMemberMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *OrgUnitMemberMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *OrgUnitMemberMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the OrgUnitMember entity.
// If the OrgUnitMember object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrgUnitMemberMutation) OldUpdateTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ClearUpdateTime clears the value of the "update_time" field.
func (m *OrgUnitMemberMutation) ClearUpdateTime() {
	m.update_time = nil
	m.clearedFields[orgunitmember.FieldUpdateTime] = struct{}{}
}

// UpdateTimeCleared returns if the "update_time" field was cleared in this mutation.
func (m *OrgUnitMemberMutation) UpdateTimeCleared() bool {
	_, ok := m.clearedFields[orgunitmember.FieldUpdateTime]
	return ok
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *OrgUnitMemberMutation) ResetUpdateTime() {
	m.update_time = nil
	delete(m.clearedFields, orgunitmember.FieldUpdateTime)
}

// SetIsAdditional sets the "is_additional" field.
func (m *OrgUnitMemberMutation) SetIsAdditional(b bool) {
	m.is_additional = &b
}

// IsAdditional returns the value of the "is_additional" field in the mutation.
func (m *OrgUnitMemberMutation) IsAdditional() (r bool, exists bool) {
	v := m.is_additional
	if v == nil {
		return
	}
	return *v, true
}

// OldIsAdditional returns the old "is_additional" field's value of the OrgUnitMember entity.
// If the OrgUnitMember object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrgUnitMemberMutation) OldIsAdditional(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldIsAdditional is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldIsAdditional requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsAdditional: %w", err)
	}
	return oldValue.IsAdditional, nil
}

// ResetIsAdditional resets all changes to the "is_additional" field.
func (m *OrgUnitMemberMutation) ResetIsAdditional() {
	m.is_additional = nil
}

// SetUserID sets the "user_id" field.
func (m *OrgUnitMemberMutation) SetUserID(i int) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *OrgUnitMemberMutation) UserID() (r int, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the OrgUnitMember entity.
// If the OrgUnitMember object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrgUnitMemberMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *OrgUnitMemberMutation) ResetUserID() {
	m.user = nil
}

// SetOrgUnitID sets the "org_unit_id" field.
func (m *OrgUnitMemberMutation) SetOrgUnitID(i int) {
	m.belongToOrgUnit = &i
}

// OrgUnitID returns the value of the "org_unit_id" field in the mutation.
func (m *OrgUnitMemberMutation) OrgUnitID() (r int, exists bool) {
	v := m.belongToOrgUnit
	if v == nil {
		return
	}
	return *v, true
}

// OldOrgUnitID returns the old "org_unit_id" field's value of the OrgUnitMember entity.
// If the OrgUnitMember object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrgUnitMemberMutation) OldOrgUnitID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldOrgUnitID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldOrgUnitID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrgUnitID: %w", err)
	}
	return oldValue.OrgUnitID, nil
}

// ResetOrgUnitID resets all changes to the "org_unit_id" field.
func (m *OrgUnitMemberMutation) ResetOrgUnitID() {
	m.belongToOrgUnit = nil
}

// SetOrgUnitPositionID sets the "org_unit_position_id" field.
func (m *OrgUnitMemberMutation) SetOrgUnitPositionID(i int) {
	m.position = &i
}

// OrgUnitPositionID returns the value of the "org_unit_position_id" field in the mutation.
func (m *OrgUnitMemberMutation) OrgUnitPositionID() (r int, exists bool) {
	v := m.position
	if v == nil {
		return
	}
	return *v, true
}

// OldOrgUnitPositionID returns the old "org_unit_position_id" field's value of the OrgUnitMember entity.
// If the OrgUnitMember object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrgUnitMemberMutation) OldOrgUnitPositionID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldOrgUnitPositionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldOrgUnitPositionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrgUnitPositionID: %w", err)
	}
	return oldValue.OrgUnitPositionID, nil
}

// ResetOrgUnitPositionID resets all changes to the "org_unit_position_id" field.
func (m *OrgUnitMemberMutation) ResetOrgUnitPositionID() {
	m.position = nil
}

// SetCreateByID sets the "create_by" edge to the User entity by id.
func (m *OrgUnitMemberMutation) SetCreateByID(id int) {
	m.create_by = &id
}

// ClearCreateBy clears the "create_by" edge to the User entity.
func (m *OrgUnitMemberMutation) ClearCreateBy() {
	m.clearedcreate_by = true
}

// CreateByCleared reports if the "create_by" edge to the User entity was cleared.
func (m *OrgUnitMemberMutation) CreateByCleared() bool {
	return m.CreateByUserCleared() || m.clearedcreate_by
}

// CreateByID returns the "create_by" edge ID in the mutation.
func (m *OrgUnitMemberMutation) CreateByID() (id int, exists bool) {
	if m.create_by != nil {
		return *m.create_by, true
	}
	return
}

// CreateByIDs returns the "create_by" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CreateByID instead. It exists only for internal usage by the builders.
func (m *OrgUnitMemberMutation) CreateByIDs() (ids []int) {
	if id := m.create_by; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCreateBy resets all changes to the "create_by" edge.
func (m *OrgUnitMemberMutation) ResetCreateBy() {
	m.create_by = nil
	m.clearedcreate_by = false
}

// SetUpdateByID sets the "update_by" edge to the User entity by id.
func (m *OrgUnitMemberMutation) SetUpdateByID(id int) {
	m.update_by = &id
}

// ClearUpdateBy clears the "update_by" edge to the User entity.
func (m *OrgUnitMemberMutation) ClearUpdateBy() {
	m.clearedupdate_by = true
}

// UpdateByCleared reports if the "update_by" edge to the User entity was cleared.
func (m *OrgUnitMemberMutation) UpdateByCleared() bool {
	return m.UpdateByUserCleared() || m.clearedupdate_by
}

// UpdateByID returns the "update_by" edge ID in the mutation.
func (m *OrgUnitMemberMutation) UpdateByID() (id int, exists bool) {
	if m.update_by != nil {
		return *m.update_by, true
	}
	return
}

// UpdateByIDs returns the "update_by" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UpdateByID instead. It exists only for internal usage by the builders.
func (m *OrgUnitMemberMutation) UpdateByIDs() (ids []int) {
	if id := m.update_by; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUpdateBy resets all changes to the "update_by" edge.
func (m *OrgUnitMemberMutation) ResetUpdateBy() {
	m.update_by = nil
	m.clearedupdate_by = false
}

// ClearUser clears the "user" edge to the User entity.
func (m *OrgUnitMemberMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *OrgUnitMemberMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *OrgUnitMemberMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *OrgUnitMemberMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// SetPositionID sets the "position" edge to the OrgUnitPosition entity by id.
func (m *OrgUnitMemberMutation) SetPositionID(id int) {
	m.position = &id
}

// ClearPosition clears the "position" edge to the OrgUnitPosition entity.
func (m *OrgUnitMemberMutation) ClearPosition() {
	m.clearedposition = true
}

// PositionCleared reports if the "position" edge to the OrgUnitPosition entity was cleared.
func (m *OrgUnitMemberMutation) PositionCleared() bool {
	return m.clearedposition
}

// PositionID returns the "position" edge ID in the mutation.
func (m *OrgUnitMemberMutation) PositionID() (id int, exists bool) {
	if m.position != nil {
		return *m.position, true
	}
	return
}

// PositionIDs returns the "position" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PositionID instead. It exists only for internal usage by the builders.
func (m *OrgUnitMemberMutation) PositionIDs() (ids []int) {
	if id := m.position; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPosition resets all changes to the "position" edge.
func (m *OrgUnitMemberMutation) ResetPosition() {
	m.position = nil
	m.clearedposition = false
}

// SetBelongToOrgUnitID sets the "belongToOrgUnit" edge to the OrgUnit entity by id.
func (m *OrgUnitMemberMutation) SetBelongToOrgUnitID(id int) {
	m.belongToOrgUnit = &id
}

// ClearBelongToOrgUnit clears the "belongToOrgUnit" edge to the OrgUnit entity.
func (m *OrgUnitMemberMutation) ClearBelongToOrgUnit() {
	m.clearedbelongToOrgUnit = true
}

// BelongToOrgUnitCleared reports if the "belongToOrgUnit" edge to the OrgUnit entity was cleared.
func (m *OrgUnitMemberMutation) BelongToOrgUnitCleared() bool {
	return m.clearedbelongToOrgUnit
}

// BelongToOrgUnitID returns the "belongToOrgUnit" edge ID in the mutation.
func (m *OrgUnitMemberMutation) BelongToOrgUnitID() (id int, exists bool) {
	if m.belongToOrgUnit != nil {
		return *m.belongToOrgUnit, true
	}
	return
}

// BelongToOrgUnitIDs returns the "belongToOrgUnit" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BelongToOrgUnitID instead. It exists only for internal usage by the builders.
func (m *OrgUnitMemberMutation) BelongToOrgUnitIDs() (ids []int) {
	if id := m.belongToOrgUnit; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBelongToOrgUnit resets all changes to the "belongToOrgUnit" edge.
func (m *OrgUnitMemberMutation) ResetBelongToOrgUnit() {
	m.belongToOrgUnit = nil
	m.clearedbelongToOrgUnit = false
}

// Where appends a list predicates to the OrgUnitMemberMutation builder.
func (m *OrgUnitMemberMutation) Where(ps ...predicate.OrgUnitMember) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *OrgUnitMemberMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (OrgUnitMember).
func (m *OrgUnitMemberMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OrgUnitMemberMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.create_by != nil {
		fields = append(fields, orgunitmember.FieldCreateByUser)
	}
	if m.update_by != nil {
		fields = append(fields, orgunitmember.FieldUpdateByUser)
	}
	if m.create_time != nil {
		fields = append(fields, orgunitmember.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, orgunitmember.FieldUpdateTime)
	}
	if m.is_additional != nil {
		fields = append(fields, orgunitmember.FieldIsAdditional)
	}
	if m.user != nil {
		fields = append(fields, orgunitmember.FieldUserID)
	}
	if m.belongToOrgUnit != nil {
		fields = append(fields, orgunitmember.FieldOrgUnitID)
	}
	if m.position != nil {
		fields = append(fields, orgunitmember.FieldOrgUnitPositionID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OrgUnitMemberMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case orgunitmember.FieldCreateByUser:
		return m.CreateByUser()
	case orgunitmember.FieldUpdateByUser:
		return m.UpdateByUser()
	case orgunitmember.FieldCreateTime:
		return m.CreateTime()
	case orgunitmember.FieldUpdateTime:
		return m.UpdateTime()
	case orgunitmember.FieldIsAdditional:
		return m.IsAdditional()
	case orgunitmember.FieldUserID:
		return m.UserID()
	case orgunitmember.FieldOrgUnitID:
		return m.OrgUnitID()
	case orgunitmember.FieldOrgUnitPositionID:
		return m.OrgUnitPositionID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OrgUnitMemberMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case orgunitmember.FieldCreateByUser:
		return m.OldCreateByUser(ctx)
	case orgunitmember.FieldUpdateByUser:
		return m.OldUpdateByUser(ctx)
	case orgunitmember.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case orgunitmember.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case orgunitmember.FieldIsAdditional:
		return m.OldIsAdditional(ctx)
	case orgunitmember.FieldUserID:
		return m.OldUserID(ctx)
	case orgunitmember.FieldOrgUnitID:
		return m.OldOrgUnitID(ctx)
	case orgunitmember.FieldOrgUnitPositionID:
		return m.OldOrgUnitPositionID(ctx)
	}
	return nil, fmt.Errorf("unknown OrgUnitMember field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrgUnitMemberMutation) SetField(name string, value ent.Value) error {
	switch name {
	case orgunitmember.FieldCreateByUser:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateByUser(v)
		return nil
	case orgunitmember.FieldUpdateByUser:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateByUser(v)
		return nil
	case orgunitmember.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case orgunitmember.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case orgunitmember.FieldIsAdditional:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsAdditional(v)
		return nil
	case orgunitmember.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case orgunitmember.FieldOrgUnitID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrgUnitID(v)
		return nil
	case orgunitmember.FieldOrgUnitPositionID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrgUnitPositionID(v)
		return nil
	}
	return fmt.Errorf("unknown OrgUnitMember field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OrgUnitMemberMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OrgUnitMemberMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrgUnitMemberMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown OrgUnitMember numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OrgUnitMemberMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(orgunitmember.FieldCreateByUser) {
		fields = append(fields, orgunitmember.FieldCreateByUser)
	}
	if m.FieldCleared(orgunitmember.FieldUpdateByUser) {
		fields = append(fields, orgunitmember.FieldUpdateByUser)
	}
	if m.FieldCleared(orgunitmember.FieldUpdateTime) {
		fields = append(fields, orgunitmember.FieldUpdateTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OrgUnitMemberMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OrgUnitMemberMutation) ClearField(name string) error {
	switch name {
	case orgunitmember.FieldCreateByUser:
		m.ClearCreateByUser()
		return nil
	case orgunitmember.FieldUpdateByUser:
		m.ClearUpdateByUser()
		return nil
	case orgunitmember.FieldUpdateTime:
		m.ClearUpdateTime()
		return nil
	}
	return fmt.Errorf("unknown OrgUnitMember nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OrgUnitMemberMutation) ResetField(name string) error {
	switch name {
	case orgunitmember.FieldCreateByUser:
		m.ResetCreateByUser()
		return nil
	case orgunitmember.FieldUpdateByUser:
		m.ResetUpdateByUser()
		return nil
	case orgunitmember.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case orgunitmember.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case orgunitmember.FieldIsAdditional:
		m.ResetIsAdditional()
		return nil
	case orgunitmember.FieldUserID:
		m.ResetUserID()
		return nil
	case orgunitmember.FieldOrgUnitID:
		m.ResetOrgUnitID()
		return nil
	case orgunitmember.FieldOrgUnitPositionID:
		m.ResetOrgUnitPositionID()
		return nil
	}
	return fmt.Errorf("unknown OrgUnitMember field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OrgUnitMemberMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.create_by != nil {
		edges = append(edges, orgunitmember.EdgeCreateBy)
	}
	if m.update_by != nil {
		edges = append(edges, orgunitmember.EdgeUpdateBy)
	}
	if m.user != nil {
		edges = append(edges, orgunitmember.EdgeUser)
	}
	if m.position != nil {
		edges = append(edges, orgunitmember.EdgePosition)
	}
	if m.belongToOrgUnit != nil {
		edges = append(edges, orgunitmember.EdgeBelongToOrgUnit)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OrgUnitMemberMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case orgunitmember.EdgeCreateBy:
		if id := m.create_by; id != nil {
			return []ent.Value{*id}
		}
	case orgunitmember.EdgeUpdateBy:
		if id := m.update_by; id != nil {
			return []ent.Value{*id}
		}
	case orgunitmember.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case orgunitmember.EdgePosition:
		if id := m.position; id != nil {
			return []ent.Value{*id}
		}
	case orgunitmember.EdgeBelongToOrgUnit:
		if id := m.belongToOrgUnit; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OrgUnitMemberMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OrgUnitMemberMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OrgUnitMemberMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedcreate_by {
		edges = append(edges, orgunitmember.EdgeCreateBy)
	}
	if m.clearedupdate_by {
		edges = append(edges, orgunitmember.EdgeUpdateBy)
	}
	if m.cleareduser {
		edges = append(edges, orgunitmember.EdgeUser)
	}
	if m.clearedposition {
		edges = append(edges, orgunitmember.EdgePosition)
	}
	if m.clearedbelongToOrgUnit {
		edges = append(edges, orgunitmember.EdgeBelongToOrgUnit)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OrgUnitMemberMutation) EdgeCleared(name string) bool {
	switch name {
	case orgunitmember.EdgeCreateBy:
		return m.clearedcreate_by
	case orgunitmember.EdgeUpdateBy:
		return m.clearedupdate_by
	case orgunitmember.EdgeUser:
		return m.cleareduser
	case orgunitmember.EdgePosition:
		return m.clearedposition
	case orgunitmember.EdgeBelongToOrgUnit:
		return m.clearedbelongToOrgUnit
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OrgUnitMemberMutation) ClearEdge(name string) error {
	switch name {
	case orgunitmember.EdgeCreateBy:
		m.ClearCreateBy()
		return nil
	case orgunitmember.EdgeUpdateBy:
		m.ClearUpdateBy()
		return nil
	case orgunitmember.EdgeUser:
		m.ClearUser()
		return nil
	case orgunitmember.EdgePosition:
		m.ClearPosition()
		return nil
	case orgunitmember.EdgeBelongToOrgUnit:
		m.ClearBelongToOrgUnit()
		return nil
	}
	return fmt.Errorf("unknown OrgUnitMember unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OrgUnitMemberMutation) ResetEdge(name string) error {
	switch name {
	case orgunitmember.EdgeCreateBy:
		m.ResetCreateBy()
		return nil
	case orgunitmember.EdgeUpdateBy:
		m.ResetUpdateBy()
		return nil
	case orgunitmember.EdgeUser:
		m.ResetUser()
		return nil
	case orgunitmember.EdgePosition:
		m.ResetPosition()
		return nil
	case orgunitmember.EdgeBelongToOrgUnit:
		m.ResetBelongToOrgUnit()
		return nil
	}
	return fmt.Errorf("unknown OrgUnitMember edge %s", name)
}

// OrgUnitPositionMutation represents an operation that mutates the OrgUnitPosition nodes in the graph.
type OrgUnitPositionMutation struct {
	config
	op                            Op
	typ                           string
	id                            *int
	create_time                   *time.Time
	update_time                   *time.Time
	name                          *string
	duty                          *string
	level                         *int
	addlevel                      *int
	clearedFields                 map[string]struct{}
	create_by                     *int
	clearedcreate_by              bool
	update_by                     *int
	clearedupdate_by              bool
	belongToOrgUnitMembers        map[int]struct{}
	removedbelongToOrgUnitMembers map[int]struct{}
	clearedbelongToOrgUnitMembers bool
	belongToOrgUnit               *int
	clearedbelongToOrgUnit        bool
	done                          bool
	oldValue                      func(context.Context) (*OrgUnitPosition, error)
	predicates                    []predicate.OrgUnitPosition
}

var _ ent.Mutation = (*OrgUnitPositionMutation)(nil)

// orgunitpositionOption allows management of the mutation configuration using functional options.
type orgunitpositionOption func(*OrgUnitPositionMutation)

// newOrgUnitPositionMutation creates new mutation for the OrgUnitPosition entity.
func newOrgUnitPositionMutation(c config, op Op, opts ...orgunitpositionOption) *OrgUnitPositionMutation {
	m := &OrgUnitPositionMutation{
		config:        c,
		op:            op,
		typ:           TypeOrgUnitPosition,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOrgUnitPositionID sets the ID field of the mutation.
func withOrgUnitPositionID(id int) orgunitpositionOption {
	return func(m *OrgUnitPositionMutation) {
		var (
			err   error
			once  sync.Once
			value *OrgUnitPosition
		)
		m.oldValue = func(ctx context.Context) (*OrgUnitPosition, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OrgUnitPosition.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOrgUnitPosition sets the old OrgUnitPosition of the mutation.
func withOrgUnitPosition(node *OrgUnitPosition) orgunitpositionOption {
	return func(m *OrgUnitPositionMutation) {
		m.oldValue = func(context.Context) (*OrgUnitPosition, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OrgUnitPositionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OrgUnitPositionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OrgUnitPositionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateByUser sets the "create_by_user" field.
func (m *OrgUnitPositionMutation) SetCreateByUser(i int) {
	m.create_by = &i
}

// CreateByUser returns the value of the "create_by_user" field in the mutation.
func (m *OrgUnitPositionMutation) CreateByUser() (r int, exists bool) {
	v := m.create_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateByUser returns the old "create_by_user" field's value of the OrgUnitPosition entity.
// If the OrgUnitPosition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrgUnitPositionMutation) OldCreateByUser(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateByUser is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateByUser requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateByUser: %w", err)
	}
	return oldValue.CreateByUser, nil
}

// ClearCreateByUser clears the value of the "create_by_user" field.
func (m *OrgUnitPositionMutation) ClearCreateByUser() {
	m.create_by = nil
	m.clearedFields[orgunitposition.FieldCreateByUser] = struct{}{}
}

// CreateByUserCleared returns if the "create_by_user" field was cleared in this mutation.
func (m *OrgUnitPositionMutation) CreateByUserCleared() bool {
	_, ok := m.clearedFields[orgunitposition.FieldCreateByUser]
	return ok
}

// ResetCreateByUser resets all changes to the "create_by_user" field.
func (m *OrgUnitPositionMutation) ResetCreateByUser() {
	m.create_by = nil
	delete(m.clearedFields, orgunitposition.FieldCreateByUser)
}

// SetUpdateByUser sets the "update_by_user" field.
func (m *OrgUnitPositionMutation) SetUpdateByUser(i int) {
	m.update_by = &i
}

// UpdateByUser returns the value of the "update_by_user" field in the mutation.
func (m *OrgUnitPositionMutation) UpdateByUser() (r int, exists bool) {
	v := m.update_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateByUser returns the old "update_by_user" field's value of the OrgUnitPosition entity.
// If the OrgUnitPosition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrgUnitPositionMutation) OldUpdateByUser(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateByUser is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateByUser requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateByUser: %w", err)
	}
	return oldValue.UpdateByUser, nil
}

// ClearUpdateByUser clears the value of the "update_by_user" field.
func (m *OrgUnitPositionMutation) ClearUpdateByUser() {
	m.update_by = nil
	m.clearedFields[orgunitposition.FieldUpdateByUser] = struct{}{}
}

// UpdateByUserCleared returns if the "update_by_user" field was cleared in this mutation.
func (m *OrgUnitPositionMutation) UpdateByUserCleared() bool {
	_, ok := m.clearedFields[orgunitposition.FieldUpdateByUser]
	return ok
}

// ResetUpdateByUser resets all changes to the "update_by_user" field.
func (m *OrgUnitPositionMutation) ResetUpdateByUser() {
	m.update_by = nil
	delete(m.clearedFields, orgunitposition.FieldUpdateByUser)
}

// SetCreateTime sets the "create_time" field.
func (m *OrgUnitPositionMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *OrgUnitPositionMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the OrgUnitPosition entity.
// If the OrgUnitPosition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrgUnitPositionMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *OrgUnitPositionMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *OrgUnitPositionMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *OrgUnitPositionMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the OrgUnitPosition entity.
// If the OrgUnitPosition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrgUnitPositionMutation) OldUpdateTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ClearUpdateTime clears the value of the "update_time" field.
func (m *OrgUnitPositionMutation) ClearUpdateTime() {
	m.update_time = nil
	m.clearedFields[orgunitposition.FieldUpdateTime] = struct{}{}
}

// UpdateTimeCleared returns if the "update_time" field was cleared in this mutation.
func (m *OrgUnitPositionMutation) UpdateTimeCleared() bool {
	_, ok := m.clearedFields[orgunitposition.FieldUpdateTime]
	return ok
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *OrgUnitPositionMutation) ResetUpdateTime() {
	m.update_time = nil
	delete(m.clearedFields, orgunitposition.FieldUpdateTime)
}

// SetName sets the "name" field.
func (m *OrgUnitPositionMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *OrgUnitPositionMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the OrgUnitPosition entity.
// If the OrgUnitPosition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrgUnitPositionMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *OrgUnitPositionMutation) ResetName() {
	m.name = nil
}

// SetDuty sets the "duty" field.
func (m *OrgUnitPositionMutation) SetDuty(s string) {
	m.duty = &s
}

// Duty returns the value of the "duty" field in the mutation.
func (m *OrgUnitPositionMutation) Duty() (r string, exists bool) {
	v := m.duty
	if v == nil {
		return
	}
	return *v, true
}

// OldDuty returns the old "duty" field's value of the OrgUnitPosition entity.
// If the OrgUnitPosition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrgUnitPositionMutation) OldDuty(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDuty is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDuty requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDuty: %w", err)
	}
	return oldValue.Duty, nil
}

// ClearDuty clears the value of the "duty" field.
func (m *OrgUnitPositionMutation) ClearDuty() {
	m.duty = nil
	m.clearedFields[orgunitposition.FieldDuty] = struct{}{}
}

// DutyCleared returns if the "duty" field was cleared in this mutation.
func (m *OrgUnitPositionMutation) DutyCleared() bool {
	_, ok := m.clearedFields[orgunitposition.FieldDuty]
	return ok
}

// ResetDuty resets all changes to the "duty" field.
func (m *OrgUnitPositionMutation) ResetDuty() {
	m.duty = nil
	delete(m.clearedFields, orgunitposition.FieldDuty)
}

// SetLevel sets the "level" field.
func (m *OrgUnitPositionMutation) SetLevel(i int) {
	m.level = &i
	m.addlevel = nil
}

// Level returns the value of the "level" field in the mutation.
func (m *OrgUnitPositionMutation) Level() (r int, exists bool) {
	v := m.level
	if v == nil {
		return
	}
	return *v, true
}

// OldLevel returns the old "level" field's value of the OrgUnitPosition entity.
// If the OrgUnitPosition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrgUnitPositionMutation) OldLevel(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldLevel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldLevel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLevel: %w", err)
	}
	return oldValue.Level, nil
}

// AddLevel adds i to the "level" field.
func (m *OrgUnitPositionMutation) AddLevel(i int) {
	if m.addlevel != nil {
		*m.addlevel += i
	} else {
		m.addlevel = &i
	}
}

// AddedLevel returns the value that was added to the "level" field in this mutation.
func (m *OrgUnitPositionMutation) AddedLevel() (r int, exists bool) {
	v := m.addlevel
	if v == nil {
		return
	}
	return *v, true
}

// ResetLevel resets all changes to the "level" field.
func (m *OrgUnitPositionMutation) ResetLevel() {
	m.level = nil
	m.addlevel = nil
}

// SetOrgUnitID sets the "org_unit_id" field.
func (m *OrgUnitPositionMutation) SetOrgUnitID(i int) {
	m.belongToOrgUnit = &i
}

// OrgUnitID returns the value of the "org_unit_id" field in the mutation.
func (m *OrgUnitPositionMutation) OrgUnitID() (r int, exists bool) {
	v := m.belongToOrgUnit
	if v == nil {
		return
	}
	return *v, true
}

// OldOrgUnitID returns the old "org_unit_id" field's value of the OrgUnitPosition entity.
// If the OrgUnitPosition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrgUnitPositionMutation) OldOrgUnitID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldOrgUnitID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldOrgUnitID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrgUnitID: %w", err)
	}
	return oldValue.OrgUnitID, nil
}

// ResetOrgUnitID resets all changes to the "org_unit_id" field.
func (m *OrgUnitPositionMutation) ResetOrgUnitID() {
	m.belongToOrgUnit = nil
}

// SetCreateByID sets the "create_by" edge to the User entity by id.
func (m *OrgUnitPositionMutation) SetCreateByID(id int) {
	m.create_by = &id
}

// ClearCreateBy clears the "create_by" edge to the User entity.
func (m *OrgUnitPositionMutation) ClearCreateBy() {
	m.clearedcreate_by = true
}

// CreateByCleared reports if the "create_by" edge to the User entity was cleared.
func (m *OrgUnitPositionMutation) CreateByCleared() bool {
	return m.CreateByUserCleared() || m.clearedcreate_by
}

// CreateByID returns the "create_by" edge ID in the mutation.
func (m *OrgUnitPositionMutation) CreateByID() (id int, exists bool) {
	if m.create_by != nil {
		return *m.create_by, true
	}
	return
}

// CreateByIDs returns the "create_by" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CreateByID instead. It exists only for internal usage by the builders.
func (m *OrgUnitPositionMutation) CreateByIDs() (ids []int) {
	if id := m.create_by; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCreateBy resets all changes to the "create_by" edge.
func (m *OrgUnitPositionMutation) ResetCreateBy() {
	m.create_by = nil
	m.clearedcreate_by = false
}

// SetUpdateByID sets the "update_by" edge to the User entity by id.
func (m *OrgUnitPositionMutation) SetUpdateByID(id int) {
	m.update_by = &id
}

// ClearUpdateBy clears the "update_by" edge to the User entity.
func (m *OrgUnitPositionMutation) ClearUpdateBy() {
	m.clearedupdate_by = true
}

// UpdateByCleared reports if the "update_by" edge to the User entity was cleared.
func (m *OrgUnitPositionMutation) UpdateByCleared() bool {
	return m.UpdateByUserCleared() || m.clearedupdate_by
}

// UpdateByID returns the "update_by" edge ID in the mutation.
func (m *OrgUnitPositionMutation) UpdateByID() (id int, exists bool) {
	if m.update_by != nil {
		return *m.update_by, true
	}
	return
}

// UpdateByIDs returns the "update_by" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UpdateByID instead. It exists only for internal usage by the builders.
func (m *OrgUnitPositionMutation) UpdateByIDs() (ids []int) {
	if id := m.update_by; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUpdateBy resets all changes to the "update_by" edge.
func (m *OrgUnitPositionMutation) ResetUpdateBy() {
	m.update_by = nil
	m.clearedupdate_by = false
}

// AddBelongToOrgUnitMemberIDs adds the "belongToOrgUnitMembers" edge to the OrgUnitMember entity by ids.
func (m *OrgUnitPositionMutation) AddBelongToOrgUnitMemberIDs(ids ...int) {
	if m.belongToOrgUnitMembers == nil {
		m.belongToOrgUnitMembers = make(map[int]struct{})
	}
	for i := range ids {
		m.belongToOrgUnitMembers[ids[i]] = struct{}{}
	}
}

// ClearBelongToOrgUnitMembers clears the "belongToOrgUnitMembers" edge to the OrgUnitMember entity.
func (m *OrgUnitPositionMutation) ClearBelongToOrgUnitMembers() {
	m.clearedbelongToOrgUnitMembers = true
}

// BelongToOrgUnitMembersCleared reports if the "belongToOrgUnitMembers" edge to the OrgUnitMember entity was cleared.
func (m *OrgUnitPositionMutation) BelongToOrgUnitMembersCleared() bool {
	return m.clearedbelongToOrgUnitMembers
}

// RemoveBelongToOrgUnitMemberIDs removes the "belongToOrgUnitMembers" edge to the OrgUnitMember entity by IDs.
func (m *OrgUnitPositionMutation) RemoveBelongToOrgUnitMemberIDs(ids ...int) {
	if m.removedbelongToOrgUnitMembers == nil {
		m.removedbelongToOrgUnitMembers = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.belongToOrgUnitMembers, ids[i])
		m.removedbelongToOrgUnitMembers[ids[i]] = struct{}{}
	}
}

// RemovedBelongToOrgUnitMembers returns the removed IDs of the "belongToOrgUnitMembers" edge to the OrgUnitMember entity.
func (m *OrgUnitPositionMutation) RemovedBelongToOrgUnitMembersIDs() (ids []int) {
	for id := range m.removedbelongToOrgUnitMembers {
		ids = append(ids, id)
	}
	return
}

// BelongToOrgUnitMembersIDs returns the "belongToOrgUnitMembers" edge IDs in the mutation.
func (m *OrgUnitPositionMutation) BelongToOrgUnitMembersIDs() (ids []int) {
	for id := range m.belongToOrgUnitMembers {
		ids = append(ids, id)
	}
	return
}

// ResetBelongToOrgUnitMembers resets all changes to the "belongToOrgUnitMembers" edge.
func (m *OrgUnitPositionMutation) ResetBelongToOrgUnitMembers() {
	m.belongToOrgUnitMembers = nil
	m.clearedbelongToOrgUnitMembers = false
	m.removedbelongToOrgUnitMembers = nil
}

// SetBelongToOrgUnitID sets the "belongToOrgUnit" edge to the OrgUnit entity by id.
func (m *OrgUnitPositionMutation) SetBelongToOrgUnitID(id int) {
	m.belongToOrgUnit = &id
}

// ClearBelongToOrgUnit clears the "belongToOrgUnit" edge to the OrgUnit entity.
func (m *OrgUnitPositionMutation) ClearBelongToOrgUnit() {
	m.clearedbelongToOrgUnit = true
}

// BelongToOrgUnitCleared reports if the "belongToOrgUnit" edge to the OrgUnit entity was cleared.
func (m *OrgUnitPositionMutation) BelongToOrgUnitCleared() bool {
	return m.clearedbelongToOrgUnit
}

// BelongToOrgUnitID returns the "belongToOrgUnit" edge ID in the mutation.
func (m *OrgUnitPositionMutation) BelongToOrgUnitID() (id int, exists bool) {
	if m.belongToOrgUnit != nil {
		return *m.belongToOrgUnit, true
	}
	return
}

// BelongToOrgUnitIDs returns the "belongToOrgUnit" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BelongToOrgUnitID instead. It exists only for internal usage by the builders.
func (m *OrgUnitPositionMutation) BelongToOrgUnitIDs() (ids []int) {
	if id := m.belongToOrgUnit; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBelongToOrgUnit resets all changes to the "belongToOrgUnit" edge.
func (m *OrgUnitPositionMutation) ResetBelongToOrgUnit() {
	m.belongToOrgUnit = nil
	m.clearedbelongToOrgUnit = false
}

// Where appends a list predicates to the OrgUnitPositionMutation builder.
func (m *OrgUnitPositionMutation) Where(ps ...predicate.OrgUnitPosition) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *OrgUnitPositionMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (OrgUnitPosition).
func (m *OrgUnitPositionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OrgUnitPositionMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.create_by != nil {
		fields = append(fields, orgunitposition.FieldCreateByUser)
	}
	if m.update_by != nil {
		fields = append(fields, orgunitposition.FieldUpdateByUser)
	}
	if m.create_time != nil {
		fields = append(fields, orgunitposition.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, orgunitposition.FieldUpdateTime)
	}
	if m.name != nil {
		fields = append(fields, orgunitposition.FieldName)
	}
	if m.duty != nil {
		fields = append(fields, orgunitposition.FieldDuty)
	}
	if m.level != nil {
		fields = append(fields, orgunitposition.FieldLevel)
	}
	if m.belongToOrgUnit != nil {
		fields = append(fields, orgunitposition.FieldOrgUnitID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OrgUnitPositionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case orgunitposition.FieldCreateByUser:
		return m.CreateByUser()
	case orgunitposition.FieldUpdateByUser:
		return m.UpdateByUser()
	case orgunitposition.FieldCreateTime:
		return m.CreateTime()
	case orgunitposition.FieldUpdateTime:
		return m.UpdateTime()
	case orgunitposition.FieldName:
		return m.Name()
	case orgunitposition.FieldDuty:
		return m.Duty()
	case orgunitposition.FieldLevel:
		return m.Level()
	case orgunitposition.FieldOrgUnitID:
		return m.OrgUnitID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OrgUnitPositionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case orgunitposition.FieldCreateByUser:
		return m.OldCreateByUser(ctx)
	case orgunitposition.FieldUpdateByUser:
		return m.OldUpdateByUser(ctx)
	case orgunitposition.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case orgunitposition.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case orgunitposition.FieldName:
		return m.OldName(ctx)
	case orgunitposition.FieldDuty:
		return m.OldDuty(ctx)
	case orgunitposition.FieldLevel:
		return m.OldLevel(ctx)
	case orgunitposition.FieldOrgUnitID:
		return m.OldOrgUnitID(ctx)
	}
	return nil, fmt.Errorf("unknown OrgUnitPosition field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrgUnitPositionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case orgunitposition.FieldCreateByUser:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateByUser(v)
		return nil
	case orgunitposition.FieldUpdateByUser:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateByUser(v)
		return nil
	case orgunitposition.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case orgunitposition.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case orgunitposition.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case orgunitposition.FieldDuty:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDuty(v)
		return nil
	case orgunitposition.FieldLevel:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLevel(v)
		return nil
	case orgunitposition.FieldOrgUnitID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrgUnitID(v)
		return nil
	}
	return fmt.Errorf("unknown OrgUnitPosition field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OrgUnitPositionMutation) AddedFields() []string {
	var fields []string
	if m.addlevel != nil {
		fields = append(fields, orgunitposition.FieldLevel)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OrgUnitPositionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case orgunitposition.FieldLevel:
		return m.AddedLevel()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrgUnitPositionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case orgunitposition.FieldLevel:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLevel(v)
		return nil
	}
	return fmt.Errorf("unknown OrgUnitPosition numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OrgUnitPositionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(orgunitposition.FieldCreateByUser) {
		fields = append(fields, orgunitposition.FieldCreateByUser)
	}
	if m.FieldCleared(orgunitposition.FieldUpdateByUser) {
		fields = append(fields, orgunitposition.FieldUpdateByUser)
	}
	if m.FieldCleared(orgunitposition.FieldUpdateTime) {
		fields = append(fields, orgunitposition.FieldUpdateTime)
	}
	if m.FieldCleared(orgunitposition.FieldDuty) {
		fields = append(fields, orgunitposition.FieldDuty)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OrgUnitPositionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OrgUnitPositionMutation) ClearField(name string) error {
	switch name {
	case orgunitposition.FieldCreateByUser:
		m.ClearCreateByUser()
		return nil
	case orgunitposition.FieldUpdateByUser:
		m.ClearUpdateByUser()
		return nil
	case orgunitposition.FieldUpdateTime:
		m.ClearUpdateTime()
		return nil
	case orgunitposition.FieldDuty:
		m.ClearDuty()
		return nil
	}
	return fmt.Errorf("unknown OrgUnitPosition nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OrgUnitPositionMutation) ResetField(name string) error {
	switch name {
	case orgunitposition.FieldCreateByUser:
		m.ResetCreateByUser()
		return nil
	case orgunitposition.FieldUpdateByUser:
		m.ResetUpdateByUser()
		return nil
	case orgunitposition.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case orgunitposition.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case orgunitposition.FieldName:
		m.ResetName()
		return nil
	case orgunitposition.FieldDuty:
		m.ResetDuty()
		return nil
	case orgunitposition.FieldLevel:
		m.ResetLevel()
		return nil
	case orgunitposition.FieldOrgUnitID:
		m.ResetOrgUnitID()
		return nil
	}
	return fmt.Errorf("unknown OrgUnitPosition field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OrgUnitPositionMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.create_by != nil {
		edges = append(edges, orgunitposition.EdgeCreateBy)
	}
	if m.update_by != nil {
		edges = append(edges, orgunitposition.EdgeUpdateBy)
	}
	if m.belongToOrgUnitMembers != nil {
		edges = append(edges, orgunitposition.EdgeBelongToOrgUnitMembers)
	}
	if m.belongToOrgUnit != nil {
		edges = append(edges, orgunitposition.EdgeBelongToOrgUnit)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OrgUnitPositionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case orgunitposition.EdgeCreateBy:
		if id := m.create_by; id != nil {
			return []ent.Value{*id}
		}
	case orgunitposition.EdgeUpdateBy:
		if id := m.update_by; id != nil {
			return []ent.Value{*id}
		}
	case orgunitposition.EdgeBelongToOrgUnitMembers:
		ids := make([]ent.Value, 0, len(m.belongToOrgUnitMembers))
		for id := range m.belongToOrgUnitMembers {
			ids = append(ids, id)
		}
		return ids
	case orgunitposition.EdgeBelongToOrgUnit:
		if id := m.belongToOrgUnit; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OrgUnitPositionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedbelongToOrgUnitMembers != nil {
		edges = append(edges, orgunitposition.EdgeBelongToOrgUnitMembers)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OrgUnitPositionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case orgunitposition.EdgeBelongToOrgUnitMembers:
		ids := make([]ent.Value, 0, len(m.removedbelongToOrgUnitMembers))
		for id := range m.removedbelongToOrgUnitMembers {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OrgUnitPositionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedcreate_by {
		edges = append(edges, orgunitposition.EdgeCreateBy)
	}
	if m.clearedupdate_by {
		edges = append(edges, orgunitposition.EdgeUpdateBy)
	}
	if m.clearedbelongToOrgUnitMembers {
		edges = append(edges, orgunitposition.EdgeBelongToOrgUnitMembers)
	}
	if m.clearedbelongToOrgUnit {
		edges = append(edges, orgunitposition.EdgeBelongToOrgUnit)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OrgUnitPositionMutation) EdgeCleared(name string) bool {
	switch name {
	case orgunitposition.EdgeCreateBy:
		return m.clearedcreate_by
	case orgunitposition.EdgeUpdateBy:
		return m.clearedupdate_by
	case orgunitposition.EdgeBelongToOrgUnitMembers:
		return m.clearedbelongToOrgUnitMembers
	case orgunitposition.EdgeBelongToOrgUnit:
		return m.clearedbelongToOrgUnit
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OrgUnitPositionMutation) ClearEdge(name string) error {
	switch name {
	case orgunitposition.EdgeCreateBy:
		m.ClearCreateBy()
		return nil
	case orgunitposition.EdgeUpdateBy:
		m.ClearUpdateBy()
		return nil
	case orgunitposition.EdgeBelongToOrgUnit:
		m.ClearBelongToOrgUnit()
		return nil
	}
	return fmt.Errorf("unknown OrgUnitPosition unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OrgUnitPositionMutation) ResetEdge(name string) error {
	switch name {
	case orgunitposition.EdgeCreateBy:
		m.ResetCreateBy()
		return nil
	case orgunitposition.EdgeUpdateBy:
		m.ResetUpdateBy()
		return nil
	case orgunitposition.EdgeBelongToOrgUnitMembers:
		m.ResetBelongToOrgUnitMembers()
		return nil
	case orgunitposition.EdgeBelongToOrgUnit:
		m.ResetBelongToOrgUnit()
		return nil
	}
	return fmt.Errorf("unknown OrgUnitPosition edge %s", name)
}

// OrganizationMutation represents an operation that mutates the Organization nodes in the graph.
type OrganizationMutation struct {
	config
	op               Op
	typ              string
	id               *int
	create_time      *time.Time
	update_time      *time.Time
	name             *string
	clearedFields    map[string]struct{}
	create_by        *int
	clearedcreate_by bool
	update_by        *int
	clearedupdate_by bool
	units            map[int]struct{}
	removedunits     map[int]struct{}
	clearedunits     bool
	staffs           map[int]struct{}
	removedstaffs    map[int]struct{}
	clearedstaffs    bool
	done             bool
	oldValue         func(context.Context) (*Organization, error)
	predicates       []predicate.Organization
}

var _ ent.Mutation = (*OrganizationMutation)(nil)

// organizationOption allows management of the mutation configuration using functional options.
type organizationOption func(*OrganizationMutation)

// newOrganizationMutation creates new mutation for the Organization entity.
func newOrganizationMutation(c config, op Op, opts ...organizationOption) *OrganizationMutation {
	m := &OrganizationMutation{
		config:        c,
		op:            op,
		typ:           TypeOrganization,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOrganizationID sets the ID field of the mutation.
func withOrganizationID(id int) organizationOption {
	return func(m *OrganizationMutation) {
		var (
			err   error
			once  sync.Once
			value *Organization
		)
		m.oldValue = func(ctx context.Context) (*Organization, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Organization.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOrganization sets the old Organization of the mutation.
func withOrganization(node *Organization) organizationOption {
	return func(m *OrganizationMutation) {
		m.oldValue = func(context.Context) (*Organization, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OrganizationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OrganizationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OrganizationMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateByUser sets the "create_by_user" field.
func (m *OrganizationMutation) SetCreateByUser(i int) {
	m.create_by = &i
}

// CreateByUser returns the value of the "create_by_user" field in the mutation.
func (m *OrganizationMutation) CreateByUser() (r int, exists bool) {
	v := m.create_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateByUser returns the old "create_by_user" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldCreateByUser(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateByUser is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateByUser requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateByUser: %w", err)
	}
	return oldValue.CreateByUser, nil
}

// ClearCreateByUser clears the value of the "create_by_user" field.
func (m *OrganizationMutation) ClearCreateByUser() {
	m.create_by = nil
	m.clearedFields[organization.FieldCreateByUser] = struct{}{}
}

// CreateByUserCleared returns if the "create_by_user" field was cleared in this mutation.
func (m *OrganizationMutation) CreateByUserCleared() bool {
	_, ok := m.clearedFields[organization.FieldCreateByUser]
	return ok
}

// ResetCreateByUser resets all changes to the "create_by_user" field.
func (m *OrganizationMutation) ResetCreateByUser() {
	m.create_by = nil
	delete(m.clearedFields, organization.FieldCreateByUser)
}

// SetUpdateByUser sets the "update_by_user" field.
func (m *OrganizationMutation) SetUpdateByUser(i int) {
	m.update_by = &i
}

// UpdateByUser returns the value of the "update_by_user" field in the mutation.
func (m *OrganizationMutation) UpdateByUser() (r int, exists bool) {
	v := m.update_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateByUser returns the old "update_by_user" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldUpdateByUser(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateByUser is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateByUser requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateByUser: %w", err)
	}
	return oldValue.UpdateByUser, nil
}

// ClearUpdateByUser clears the value of the "update_by_user" field.
func (m *OrganizationMutation) ClearUpdateByUser() {
	m.update_by = nil
	m.clearedFields[organization.FieldUpdateByUser] = struct{}{}
}

// UpdateByUserCleared returns if the "update_by_user" field was cleared in this mutation.
func (m *OrganizationMutation) UpdateByUserCleared() bool {
	_, ok := m.clearedFields[organization.FieldUpdateByUser]
	return ok
}

// ResetUpdateByUser resets all changes to the "update_by_user" field.
func (m *OrganizationMutation) ResetUpdateByUser() {
	m.update_by = nil
	delete(m.clearedFields, organization.FieldUpdateByUser)
}

// SetCreateTime sets the "create_time" field.
func (m *OrganizationMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *OrganizationMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *OrganizationMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *OrganizationMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *OrganizationMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldUpdateTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ClearUpdateTime clears the value of the "update_time" field.
func (m *OrganizationMutation) ClearUpdateTime() {
	m.update_time = nil
	m.clearedFields[organization.FieldUpdateTime] = struct{}{}
}

// UpdateTimeCleared returns if the "update_time" field was cleared in this mutation.
func (m *OrganizationMutation) UpdateTimeCleared() bool {
	_, ok := m.clearedFields[organization.FieldUpdateTime]
	return ok
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *OrganizationMutation) ResetUpdateTime() {
	m.update_time = nil
	delete(m.clearedFields, organization.FieldUpdateTime)
}

// SetName sets the "name" field.
func (m *OrganizationMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *OrganizationMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *OrganizationMutation) ResetName() {
	m.name = nil
}

// SetCreateByID sets the "create_by" edge to the User entity by id.
func (m *OrganizationMutation) SetCreateByID(id int) {
	m.create_by = &id
}

// ClearCreateBy clears the "create_by" edge to the User entity.
func (m *OrganizationMutation) ClearCreateBy() {
	m.clearedcreate_by = true
}

// CreateByCleared reports if the "create_by" edge to the User entity was cleared.
func (m *OrganizationMutation) CreateByCleared() bool {
	return m.CreateByUserCleared() || m.clearedcreate_by
}

// CreateByID returns the "create_by" edge ID in the mutation.
func (m *OrganizationMutation) CreateByID() (id int, exists bool) {
	if m.create_by != nil {
		return *m.create_by, true
	}
	return
}

// CreateByIDs returns the "create_by" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CreateByID instead. It exists only for internal usage by the builders.
func (m *OrganizationMutation) CreateByIDs() (ids []int) {
	if id := m.create_by; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCreateBy resets all changes to the "create_by" edge.
func (m *OrganizationMutation) ResetCreateBy() {
	m.create_by = nil
	m.clearedcreate_by = false
}

// SetUpdateByID sets the "update_by" edge to the User entity by id.
func (m *OrganizationMutation) SetUpdateByID(id int) {
	m.update_by = &id
}

// ClearUpdateBy clears the "update_by" edge to the User entity.
func (m *OrganizationMutation) ClearUpdateBy() {
	m.clearedupdate_by = true
}

// UpdateByCleared reports if the "update_by" edge to the User entity was cleared.
func (m *OrganizationMutation) UpdateByCleared() bool {
	return m.UpdateByUserCleared() || m.clearedupdate_by
}

// UpdateByID returns the "update_by" edge ID in the mutation.
func (m *OrganizationMutation) UpdateByID() (id int, exists bool) {
	if m.update_by != nil {
		return *m.update_by, true
	}
	return
}

// UpdateByIDs returns the "update_by" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UpdateByID instead. It exists only for internal usage by the builders.
func (m *OrganizationMutation) UpdateByIDs() (ids []int) {
	if id := m.update_by; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUpdateBy resets all changes to the "update_by" edge.
func (m *OrganizationMutation) ResetUpdateBy() {
	m.update_by = nil
	m.clearedupdate_by = false
}

// AddUnitIDs adds the "units" edge to the OrgUnit entity by ids.
func (m *OrganizationMutation) AddUnitIDs(ids ...int) {
	if m.units == nil {
		m.units = make(map[int]struct{})
	}
	for i := range ids {
		m.units[ids[i]] = struct{}{}
	}
}

// ClearUnits clears the "units" edge to the OrgUnit entity.
func (m *OrganizationMutation) ClearUnits() {
	m.clearedunits = true
}

// UnitsCleared reports if the "units" edge to the OrgUnit entity was cleared.
func (m *OrganizationMutation) UnitsCleared() bool {
	return m.clearedunits
}

// RemoveUnitIDs removes the "units" edge to the OrgUnit entity by IDs.
func (m *OrganizationMutation) RemoveUnitIDs(ids ...int) {
	if m.removedunits == nil {
		m.removedunits = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.units, ids[i])
		m.removedunits[ids[i]] = struct{}{}
	}
}

// RemovedUnits returns the removed IDs of the "units" edge to the OrgUnit entity.
func (m *OrganizationMutation) RemovedUnitsIDs() (ids []int) {
	for id := range m.removedunits {
		ids = append(ids, id)
	}
	return
}

// UnitsIDs returns the "units" edge IDs in the mutation.
func (m *OrganizationMutation) UnitsIDs() (ids []int) {
	for id := range m.units {
		ids = append(ids, id)
	}
	return
}

// ResetUnits resets all changes to the "units" edge.
func (m *OrganizationMutation) ResetUnits() {
	m.units = nil
	m.clearedunits = false
	m.removedunits = nil
}

// AddStaffIDs adds the "staffs" edge to the User entity by ids.
func (m *OrganizationMutation) AddStaffIDs(ids ...int) {
	if m.staffs == nil {
		m.staffs = make(map[int]struct{})
	}
	for i := range ids {
		m.staffs[ids[i]] = struct{}{}
	}
}

// ClearStaffs clears the "staffs" edge to the User entity.
func (m *OrganizationMutation) ClearStaffs() {
	m.clearedstaffs = true
}

// StaffsCleared reports if the "staffs" edge to the User entity was cleared.
func (m *OrganizationMutation) StaffsCleared() bool {
	return m.clearedstaffs
}

// RemoveStaffIDs removes the "staffs" edge to the User entity by IDs.
func (m *OrganizationMutation) RemoveStaffIDs(ids ...int) {
	if m.removedstaffs == nil {
		m.removedstaffs = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.staffs, ids[i])
		m.removedstaffs[ids[i]] = struct{}{}
	}
}

// RemovedStaffs returns the removed IDs of the "staffs" edge to the User entity.
func (m *OrganizationMutation) RemovedStaffsIDs() (ids []int) {
	for id := range m.removedstaffs {
		ids = append(ids, id)
	}
	return
}

// StaffsIDs returns the "staffs" edge IDs in the mutation.
func (m *OrganizationMutation) StaffsIDs() (ids []int) {
	for id := range m.staffs {
		ids = append(ids, id)
	}
	return
}

// ResetStaffs resets all changes to the "staffs" edge.
func (m *OrganizationMutation) ResetStaffs() {
	m.staffs = nil
	m.clearedstaffs = false
	m.removedstaffs = nil
}

// Where appends a list predicates to the OrganizationMutation builder.
func (m *OrganizationMutation) Where(ps ...predicate.Organization) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *OrganizationMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Organization).
func (m *OrganizationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OrganizationMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.create_by != nil {
		fields = append(fields, organization.FieldCreateByUser)
	}
	if m.update_by != nil {
		fields = append(fields, organization.FieldUpdateByUser)
	}
	if m.create_time != nil {
		fields = append(fields, organization.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, organization.FieldUpdateTime)
	}
	if m.name != nil {
		fields = append(fields, organization.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OrganizationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case organization.FieldCreateByUser:
		return m.CreateByUser()
	case organization.FieldUpdateByUser:
		return m.UpdateByUser()
	case organization.FieldCreateTime:
		return m.CreateTime()
	case organization.FieldUpdateTime:
		return m.UpdateTime()
	case organization.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OrganizationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case organization.FieldCreateByUser:
		return m.OldCreateByUser(ctx)
	case organization.FieldUpdateByUser:
		return m.OldUpdateByUser(ctx)
	case organization.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case organization.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case organization.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown Organization field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrganizationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case organization.FieldCreateByUser:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateByUser(v)
		return nil
	case organization.FieldUpdateByUser:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateByUser(v)
		return nil
	case organization.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case organization.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case organization.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown Organization field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OrganizationMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OrganizationMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrganizationMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Organization numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OrganizationMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(organization.FieldCreateByUser) {
		fields = append(fields, organization.FieldCreateByUser)
	}
	if m.FieldCleared(organization.FieldUpdateByUser) {
		fields = append(fields, organization.FieldUpdateByUser)
	}
	if m.FieldCleared(organization.FieldUpdateTime) {
		fields = append(fields, organization.FieldUpdateTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OrganizationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OrganizationMutation) ClearField(name string) error {
	switch name {
	case organization.FieldCreateByUser:
		m.ClearCreateByUser()
		return nil
	case organization.FieldUpdateByUser:
		m.ClearUpdateByUser()
		return nil
	case organization.FieldUpdateTime:
		m.ClearUpdateTime()
		return nil
	}
	return fmt.Errorf("unknown Organization nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OrganizationMutation) ResetField(name string) error {
	switch name {
	case organization.FieldCreateByUser:
		m.ResetCreateByUser()
		return nil
	case organization.FieldUpdateByUser:
		m.ResetUpdateByUser()
		return nil
	case organization.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case organization.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case organization.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown Organization field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OrganizationMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.create_by != nil {
		edges = append(edges, organization.EdgeCreateBy)
	}
	if m.update_by != nil {
		edges = append(edges, organization.EdgeUpdateBy)
	}
	if m.units != nil {
		edges = append(edges, organization.EdgeUnits)
	}
	if m.staffs != nil {
		edges = append(edges, organization.EdgeStaffs)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OrganizationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case organization.EdgeCreateBy:
		if id := m.create_by; id != nil {
			return []ent.Value{*id}
		}
	case organization.EdgeUpdateBy:
		if id := m.update_by; id != nil {
			return []ent.Value{*id}
		}
	case organization.EdgeUnits:
		ids := make([]ent.Value, 0, len(m.units))
		for id := range m.units {
			ids = append(ids, id)
		}
		return ids
	case organization.EdgeStaffs:
		ids := make([]ent.Value, 0, len(m.staffs))
		for id := range m.staffs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OrganizationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedunits != nil {
		edges = append(edges, organization.EdgeUnits)
	}
	if m.removedstaffs != nil {
		edges = append(edges, organization.EdgeStaffs)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OrganizationMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case organization.EdgeUnits:
		ids := make([]ent.Value, 0, len(m.removedunits))
		for id := range m.removedunits {
			ids = append(ids, id)
		}
		return ids
	case organization.EdgeStaffs:
		ids := make([]ent.Value, 0, len(m.removedstaffs))
		for id := range m.removedstaffs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OrganizationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedcreate_by {
		edges = append(edges, organization.EdgeCreateBy)
	}
	if m.clearedupdate_by {
		edges = append(edges, organization.EdgeUpdateBy)
	}
	if m.clearedunits {
		edges = append(edges, organization.EdgeUnits)
	}
	if m.clearedstaffs {
		edges = append(edges, organization.EdgeStaffs)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OrganizationMutation) EdgeCleared(name string) bool {
	switch name {
	case organization.EdgeCreateBy:
		return m.clearedcreate_by
	case organization.EdgeUpdateBy:
		return m.clearedupdate_by
	case organization.EdgeUnits:
		return m.clearedunits
	case organization.EdgeStaffs:
		return m.clearedstaffs
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OrganizationMutation) ClearEdge(name string) error {
	switch name {
	case organization.EdgeCreateBy:
		m.ClearCreateBy()
		return nil
	case organization.EdgeUpdateBy:
		m.ClearUpdateBy()
		return nil
	}
	return fmt.Errorf("unknown Organization unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OrganizationMutation) ResetEdge(name string) error {
	switch name {
	case organization.EdgeCreateBy:
		m.ResetCreateBy()
		return nil
	case organization.EdgeUpdateBy:
		m.ResetUpdateBy()
		return nil
	case organization.EdgeUnits:
		m.ResetUnits()
		return nil
	case organization.EdgeStaffs:
		m.ResetStaffs()
		return nil
	}
	return fmt.Errorf("unknown Organization edge %s", name)
}

// ResourceMutation represents an operation that mutates the Resource nodes in the graph.
type ResourceMutation struct {
	config
	op            Op
	typ           string
	id            *int
	name          *string
	_type         *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Resource, error)
	predicates    []predicate.Resource
}

var _ ent.Mutation = (*ResourceMutation)(nil)

// resourceOption allows management of the mutation configuration using functional options.
type resourceOption func(*ResourceMutation)

// newResourceMutation creates new mutation for the Resource entity.
func newResourceMutation(c config, op Op, opts ...resourceOption) *ResourceMutation {
	m := &ResourceMutation{
		config:        c,
		op:            op,
		typ:           TypeResource,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withResourceID sets the ID field of the mutation.
func withResourceID(id int) resourceOption {
	return func(m *ResourceMutation) {
		var (
			err   error
			once  sync.Once
			value *Resource
		)
		m.oldValue = func(ctx context.Context) (*Resource, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Resource.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withResource sets the old Resource of the mutation.
func withResource(node *Resource) resourceOption {
	return func(m *ResourceMutation) {
		m.oldValue = func(context.Context) (*Resource, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ResourceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ResourceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ResourceMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the "name" field.
func (m *ResourceMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ResourceMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Resource entity.
// If the Resource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ResourceMutation) ResetName() {
	m.name = nil
}

// SetType sets the "type" field.
func (m *ResourceMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *ResourceMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Resource entity.
// If the Resource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *ResourceMutation) ResetType() {
	m._type = nil
}

// Where appends a list predicates to the ResourceMutation builder.
func (m *ResourceMutation) Where(ps ...predicate.Resource) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ResourceMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Resource).
func (m *ResourceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ResourceMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.name != nil {
		fields = append(fields, resource.FieldName)
	}
	if m._type != nil {
		fields = append(fields, resource.FieldType)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ResourceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case resource.FieldName:
		return m.Name()
	case resource.FieldType:
		return m.GetType()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ResourceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case resource.FieldName:
		return m.OldName(ctx)
	case resource.FieldType:
		return m.OldType(ctx)
	}
	return nil, fmt.Errorf("unknown Resource field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ResourceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case resource.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case resource.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	}
	return fmt.Errorf("unknown Resource field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ResourceMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ResourceMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ResourceMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Resource numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ResourceMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ResourceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ResourceMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Resource nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ResourceMutation) ResetField(name string) error {
	switch name {
	case resource.FieldName:
		m.ResetName()
		return nil
	case resource.FieldType:
		m.ResetType()
		return nil
	}
	return fmt.Errorf("unknown Resource field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ResourceMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ResourceMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ResourceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ResourceMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ResourceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ResourceMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ResourceMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Resource unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ResourceMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Resource edge %s", name)
}

// SystemMutation represents an operation that mutates the System nodes in the graph.
type SystemMutation struct {
	config
	op               Op
	typ              string
	id               *int
	create_time      *time.Time
	update_time      *time.Time
	name             *string
	clearedFields    map[string]struct{}
	create_by        *int
	clearedcreate_by bool
	update_by        *int
	clearedupdate_by bool
	done             bool
	oldValue         func(context.Context) (*System, error)
	predicates       []predicate.System
}

var _ ent.Mutation = (*SystemMutation)(nil)

// systemOption allows management of the mutation configuration using functional options.
type systemOption func(*SystemMutation)

// newSystemMutation creates new mutation for the System entity.
func newSystemMutation(c config, op Op, opts ...systemOption) *SystemMutation {
	m := &SystemMutation{
		config:        c,
		op:            op,
		typ:           TypeSystem,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSystemID sets the ID field of the mutation.
func withSystemID(id int) systemOption {
	return func(m *SystemMutation) {
		var (
			err   error
			once  sync.Once
			value *System
		)
		m.oldValue = func(ctx context.Context) (*System, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().System.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSystem sets the old System of the mutation.
func withSystem(node *System) systemOption {
	return func(m *SystemMutation) {
		m.oldValue = func(context.Context) (*System, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SystemMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SystemMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SystemMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateByUser sets the "create_by_user" field.
func (m *SystemMutation) SetCreateByUser(i int) {
	m.create_by = &i
}

// CreateByUser returns the value of the "create_by_user" field in the mutation.
func (m *SystemMutation) CreateByUser() (r int, exists bool) {
	v := m.create_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateByUser returns the old "create_by_user" field's value of the System entity.
// If the System object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemMutation) OldCreateByUser(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateByUser is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateByUser requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateByUser: %w", err)
	}
	return oldValue.CreateByUser, nil
}

// ClearCreateByUser clears the value of the "create_by_user" field.
func (m *SystemMutation) ClearCreateByUser() {
	m.create_by = nil
	m.clearedFields[system.FieldCreateByUser] = struct{}{}
}

// CreateByUserCleared returns if the "create_by_user" field was cleared in this mutation.
func (m *SystemMutation) CreateByUserCleared() bool {
	_, ok := m.clearedFields[system.FieldCreateByUser]
	return ok
}

// ResetCreateByUser resets all changes to the "create_by_user" field.
func (m *SystemMutation) ResetCreateByUser() {
	m.create_by = nil
	delete(m.clearedFields, system.FieldCreateByUser)
}

// SetUpdateByUser sets the "update_by_user" field.
func (m *SystemMutation) SetUpdateByUser(i int) {
	m.update_by = &i
}

// UpdateByUser returns the value of the "update_by_user" field in the mutation.
func (m *SystemMutation) UpdateByUser() (r int, exists bool) {
	v := m.update_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateByUser returns the old "update_by_user" field's value of the System entity.
// If the System object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemMutation) OldUpdateByUser(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateByUser is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateByUser requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateByUser: %w", err)
	}
	return oldValue.UpdateByUser, nil
}

// ClearUpdateByUser clears the value of the "update_by_user" field.
func (m *SystemMutation) ClearUpdateByUser() {
	m.update_by = nil
	m.clearedFields[system.FieldUpdateByUser] = struct{}{}
}

// UpdateByUserCleared returns if the "update_by_user" field was cleared in this mutation.
func (m *SystemMutation) UpdateByUserCleared() bool {
	_, ok := m.clearedFields[system.FieldUpdateByUser]
	return ok
}

// ResetUpdateByUser resets all changes to the "update_by_user" field.
func (m *SystemMutation) ResetUpdateByUser() {
	m.update_by = nil
	delete(m.clearedFields, system.FieldUpdateByUser)
}

// SetCreateTime sets the "create_time" field.
func (m *SystemMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *SystemMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the System entity.
// If the System object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *SystemMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *SystemMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *SystemMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the System entity.
// If the System object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemMutation) OldUpdateTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ClearUpdateTime clears the value of the "update_time" field.
func (m *SystemMutation) ClearUpdateTime() {
	m.update_time = nil
	m.clearedFields[system.FieldUpdateTime] = struct{}{}
}

// UpdateTimeCleared returns if the "update_time" field was cleared in this mutation.
func (m *SystemMutation) UpdateTimeCleared() bool {
	_, ok := m.clearedFields[system.FieldUpdateTime]
	return ok
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *SystemMutation) ResetUpdateTime() {
	m.update_time = nil
	delete(m.clearedFields, system.FieldUpdateTime)
}

// SetName sets the "name" field.
func (m *SystemMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *SystemMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the System entity.
// If the System object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *SystemMutation) ResetName() {
	m.name = nil
}

// SetCreateByID sets the "create_by" edge to the User entity by id.
func (m *SystemMutation) SetCreateByID(id int) {
	m.create_by = &id
}

// ClearCreateBy clears the "create_by" edge to the User entity.
func (m *SystemMutation) ClearCreateBy() {
	m.clearedcreate_by = true
}

// CreateByCleared reports if the "create_by" edge to the User entity was cleared.
func (m *SystemMutation) CreateByCleared() bool {
	return m.CreateByUserCleared() || m.clearedcreate_by
}

// CreateByID returns the "create_by" edge ID in the mutation.
func (m *SystemMutation) CreateByID() (id int, exists bool) {
	if m.create_by != nil {
		return *m.create_by, true
	}
	return
}

// CreateByIDs returns the "create_by" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CreateByID instead. It exists only for internal usage by the builders.
func (m *SystemMutation) CreateByIDs() (ids []int) {
	if id := m.create_by; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCreateBy resets all changes to the "create_by" edge.
func (m *SystemMutation) ResetCreateBy() {
	m.create_by = nil
	m.clearedcreate_by = false
}

// SetUpdateByID sets the "update_by" edge to the User entity by id.
func (m *SystemMutation) SetUpdateByID(id int) {
	m.update_by = &id
}

// ClearUpdateBy clears the "update_by" edge to the User entity.
func (m *SystemMutation) ClearUpdateBy() {
	m.clearedupdate_by = true
}

// UpdateByCleared reports if the "update_by" edge to the User entity was cleared.
func (m *SystemMutation) UpdateByCleared() bool {
	return m.UpdateByUserCleared() || m.clearedupdate_by
}

// UpdateByID returns the "update_by" edge ID in the mutation.
func (m *SystemMutation) UpdateByID() (id int, exists bool) {
	if m.update_by != nil {
		return *m.update_by, true
	}
	return
}

// UpdateByIDs returns the "update_by" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UpdateByID instead. It exists only for internal usage by the builders.
func (m *SystemMutation) UpdateByIDs() (ids []int) {
	if id := m.update_by; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUpdateBy resets all changes to the "update_by" edge.
func (m *SystemMutation) ResetUpdateBy() {
	m.update_by = nil
	m.clearedupdate_by = false
}

// Where appends a list predicates to the SystemMutation builder.
func (m *SystemMutation) Where(ps ...predicate.System) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *SystemMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (System).
func (m *SystemMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SystemMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.create_by != nil {
		fields = append(fields, system.FieldCreateByUser)
	}
	if m.update_by != nil {
		fields = append(fields, system.FieldUpdateByUser)
	}
	if m.create_time != nil {
		fields = append(fields, system.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, system.FieldUpdateTime)
	}
	if m.name != nil {
		fields = append(fields, system.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SystemMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case system.FieldCreateByUser:
		return m.CreateByUser()
	case system.FieldUpdateByUser:
		return m.UpdateByUser()
	case system.FieldCreateTime:
		return m.CreateTime()
	case system.FieldUpdateTime:
		return m.UpdateTime()
	case system.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SystemMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case system.FieldCreateByUser:
		return m.OldCreateByUser(ctx)
	case system.FieldUpdateByUser:
		return m.OldUpdateByUser(ctx)
	case system.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case system.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case system.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown System field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SystemMutation) SetField(name string, value ent.Value) error {
	switch name {
	case system.FieldCreateByUser:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateByUser(v)
		return nil
	case system.FieldUpdateByUser:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateByUser(v)
		return nil
	case system.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case system.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case system.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown System field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SystemMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SystemMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SystemMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown System numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SystemMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(system.FieldCreateByUser) {
		fields = append(fields, system.FieldCreateByUser)
	}
	if m.FieldCleared(system.FieldUpdateByUser) {
		fields = append(fields, system.FieldUpdateByUser)
	}
	if m.FieldCleared(system.FieldUpdateTime) {
		fields = append(fields, system.FieldUpdateTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SystemMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SystemMutation) ClearField(name string) error {
	switch name {
	case system.FieldCreateByUser:
		m.ClearCreateByUser()
		return nil
	case system.FieldUpdateByUser:
		m.ClearUpdateByUser()
		return nil
	case system.FieldUpdateTime:
		m.ClearUpdateTime()
		return nil
	}
	return fmt.Errorf("unknown System nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SystemMutation) ResetField(name string) error {
	switch name {
	case system.FieldCreateByUser:
		m.ResetCreateByUser()
		return nil
	case system.FieldUpdateByUser:
		m.ResetUpdateByUser()
		return nil
	case system.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case system.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case system.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown System field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SystemMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.create_by != nil {
		edges = append(edges, system.EdgeCreateBy)
	}
	if m.update_by != nil {
		edges = append(edges, system.EdgeUpdateBy)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SystemMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case system.EdgeCreateBy:
		if id := m.create_by; id != nil {
			return []ent.Value{*id}
		}
	case system.EdgeUpdateBy:
		if id := m.update_by; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SystemMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SystemMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SystemMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedcreate_by {
		edges = append(edges, system.EdgeCreateBy)
	}
	if m.clearedupdate_by {
		edges = append(edges, system.EdgeUpdateBy)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SystemMutation) EdgeCleared(name string) bool {
	switch name {
	case system.EdgeCreateBy:
		return m.clearedcreate_by
	case system.EdgeUpdateBy:
		return m.clearedupdate_by
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SystemMutation) ClearEdge(name string) error {
	switch name {
	case system.EdgeCreateBy:
		m.ClearCreateBy()
		return nil
	case system.EdgeUpdateBy:
		m.ClearUpdateBy()
		return nil
	}
	return fmt.Errorf("unknown System unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SystemMutation) ResetEdge(name string) error {
	switch name {
	case system.EdgeCreateBy:
		m.ResetCreateBy()
		return nil
	case system.EdgeUpdateBy:
		m.ResetUpdateBy()
		return nil
	}
	return fmt.Errorf("unknown System edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op                            Op
	typ                           string
	id                            *int
	create_time                   *time.Time
	update_time                   *time.Time
	account_name                  *string
	staff_type                    *user.StaffType
	is_on_job                     *bool
	family_name                   *string
	given_name                    *string
	display_name                  *string
	birthday                      *time.Time
	id_number                     *string
	sex                           *user.Sex
	phone_number                  *string
	address                       *string
	staff_id                      *string
	personal_email                *string
	intranet_work_email           *string
	extranet_work_email           *string
	clearedFields                 map[string]struct{}
	create_by                     *int
	clearedcreate_by              bool
	update_by                     *int
	clearedupdate_by              bool
	authHistories                 map[int]struct{}
	removedauthHistories          map[int]struct{}
	clearedauthHistories          bool
	jobHistories                  map[int]struct{}
	removedjobHistories           map[int]struct{}
	clearedjobHistories           bool
	creates                       map[int]struct{}
	removedcreates                map[int]struct{}
	clearedcreates                bool
	updates                       map[int]struct{}
	removedupdates                map[int]struct{}
	clearedupdates                bool
	belongToOrgUnitMembers        map[int]struct{}
	removedbelongToOrgUnitMembers map[int]struct{}
	clearedbelongToOrgUnitMembers bool
	belongToOg                    map[int]struct{}
	removedbelongToOg             map[int]struct{}
	clearedbelongToOg             bool
	done                          bool
	oldValue                      func(context.Context) (*User, error)
	predicates                    []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id int) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateByUser sets the "create_by_user" field.
func (m *UserMutation) SetCreateByUser(i int) {
	m.create_by = &i
}

// CreateByUser returns the value of the "create_by_user" field in the mutation.
func (m *UserMutation) CreateByUser() (r int, exists bool) {
	v := m.create_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateByUser returns the old "create_by_user" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreateByUser(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateByUser is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateByUser requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateByUser: %w", err)
	}
	return oldValue.CreateByUser, nil
}

// ClearCreateByUser clears the value of the "create_by_user" field.
func (m *UserMutation) ClearCreateByUser() {
	m.create_by = nil
	m.clearedFields[user.FieldCreateByUser] = struct{}{}
}

// CreateByUserCleared returns if the "create_by_user" field was cleared in this mutation.
func (m *UserMutation) CreateByUserCleared() bool {
	_, ok := m.clearedFields[user.FieldCreateByUser]
	return ok
}

// ResetCreateByUser resets all changes to the "create_by_user" field.
func (m *UserMutation) ResetCreateByUser() {
	m.create_by = nil
	delete(m.clearedFields, user.FieldCreateByUser)
}

// SetUpdateByUser sets the "update_by_user" field.
func (m *UserMutation) SetUpdateByUser(i int) {
	m.update_by = &i
}

// UpdateByUser returns the value of the "update_by_user" field in the mutation.
func (m *UserMutation) UpdateByUser() (r int, exists bool) {
	v := m.update_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateByUser returns the old "update_by_user" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdateByUser(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateByUser is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateByUser requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateByUser: %w", err)
	}
	return oldValue.UpdateByUser, nil
}

// ClearUpdateByUser clears the value of the "update_by_user" field.
func (m *UserMutation) ClearUpdateByUser() {
	m.update_by = nil
	m.clearedFields[user.FieldUpdateByUser] = struct{}{}
}

// UpdateByUserCleared returns if the "update_by_user" field was cleared in this mutation.
func (m *UserMutation) UpdateByUserCleared() bool {
	_, ok := m.clearedFields[user.FieldUpdateByUser]
	return ok
}

// ResetUpdateByUser resets all changes to the "update_by_user" field.
func (m *UserMutation) ResetUpdateByUser() {
	m.update_by = nil
	delete(m.clearedFields, user.FieldUpdateByUser)
}

// SetCreateTime sets the "create_time" field.
func (m *UserMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *UserMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *UserMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *UserMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *UserMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdateTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ClearUpdateTime clears the value of the "update_time" field.
func (m *UserMutation) ClearUpdateTime() {
	m.update_time = nil
	m.clearedFields[user.FieldUpdateTime] = struct{}{}
}

// UpdateTimeCleared returns if the "update_time" field was cleared in this mutation.
func (m *UserMutation) UpdateTimeCleared() bool {
	_, ok := m.clearedFields[user.FieldUpdateTime]
	return ok
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *UserMutation) ResetUpdateTime() {
	m.update_time = nil
	delete(m.clearedFields, user.FieldUpdateTime)
}

// SetAccountName sets the "account_name" field.
func (m *UserMutation) SetAccountName(s string) {
	m.account_name = &s
}

// AccountName returns the value of the "account_name" field in the mutation.
func (m *UserMutation) AccountName() (r string, exists bool) {
	v := m.account_name
	if v == nil {
		return
	}
	return *v, true
}

// OldAccountName returns the old "account_name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldAccountName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAccountName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAccountName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccountName: %w", err)
	}
	return oldValue.AccountName, nil
}

// ResetAccountName resets all changes to the "account_name" field.
func (m *UserMutation) ResetAccountName() {
	m.account_name = nil
}

// SetStaffType sets the "staff_type" field.
func (m *UserMutation) SetStaffType(ut user.StaffType) {
	m.staff_type = &ut
}

// StaffType returns the value of the "staff_type" field in the mutation.
func (m *UserMutation) StaffType() (r user.StaffType, exists bool) {
	v := m.staff_type
	if v == nil {
		return
	}
	return *v, true
}

// OldStaffType returns the old "staff_type" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldStaffType(ctx context.Context) (v user.StaffType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStaffType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStaffType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStaffType: %w", err)
	}
	return oldValue.StaffType, nil
}

// ResetStaffType resets all changes to the "staff_type" field.
func (m *UserMutation) ResetStaffType() {
	m.staff_type = nil
}

// SetIsOnJob sets the "is_on_job" field.
func (m *UserMutation) SetIsOnJob(b bool) {
	m.is_on_job = &b
}

// IsOnJob returns the value of the "is_on_job" field in the mutation.
func (m *UserMutation) IsOnJob() (r bool, exists bool) {
	v := m.is_on_job
	if v == nil {
		return
	}
	return *v, true
}

// OldIsOnJob returns the old "is_on_job" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldIsOnJob(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldIsOnJob is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldIsOnJob requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsOnJob: %w", err)
	}
	return oldValue.IsOnJob, nil
}

// ResetIsOnJob resets all changes to the "is_on_job" field.
func (m *UserMutation) ResetIsOnJob() {
	m.is_on_job = nil
}

// SetFamilyName sets the "family_name" field.
func (m *UserMutation) SetFamilyName(s string) {
	m.family_name = &s
}

// FamilyName returns the value of the "family_name" field in the mutation.
func (m *UserMutation) FamilyName() (r string, exists bool) {
	v := m.family_name
	if v == nil {
		return
	}
	return *v, true
}

// OldFamilyName returns the old "family_name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldFamilyName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldFamilyName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldFamilyName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFamilyName: %w", err)
	}
	return oldValue.FamilyName, nil
}

// ResetFamilyName resets all changes to the "family_name" field.
func (m *UserMutation) ResetFamilyName() {
	m.family_name = nil
}

// SetGivenName sets the "given_name" field.
func (m *UserMutation) SetGivenName(s string) {
	m.given_name = &s
}

// GivenName returns the value of the "given_name" field in the mutation.
func (m *UserMutation) GivenName() (r string, exists bool) {
	v := m.given_name
	if v == nil {
		return
	}
	return *v, true
}

// OldGivenName returns the old "given_name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldGivenName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldGivenName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldGivenName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGivenName: %w", err)
	}
	return oldValue.GivenName, nil
}

// ResetGivenName resets all changes to the "given_name" field.
func (m *UserMutation) ResetGivenName() {
	m.given_name = nil
}

// SetDisplayName sets the "display_name" field.
func (m *UserMutation) SetDisplayName(s string) {
	m.display_name = &s
}

// DisplayName returns the value of the "display_name" field in the mutation.
func (m *UserMutation) DisplayName() (r string, exists bool) {
	v := m.display_name
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayName returns the old "display_name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldDisplayName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDisplayName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDisplayName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayName: %w", err)
	}
	return oldValue.DisplayName, nil
}

// ResetDisplayName resets all changes to the "display_name" field.
func (m *UserMutation) ResetDisplayName() {
	m.display_name = nil
}

// SetBirthday sets the "birthday" field.
func (m *UserMutation) SetBirthday(t time.Time) {
	m.birthday = &t
}

// Birthday returns the value of the "birthday" field in the mutation.
func (m *UserMutation) Birthday() (r time.Time, exists bool) {
	v := m.birthday
	if v == nil {
		return
	}
	return *v, true
}

// OldBirthday returns the old "birthday" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldBirthday(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBirthday is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBirthday requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBirthday: %w", err)
	}
	return oldValue.Birthday, nil
}

// ClearBirthday clears the value of the "birthday" field.
func (m *UserMutation) ClearBirthday() {
	m.birthday = nil
	m.clearedFields[user.FieldBirthday] = struct{}{}
}

// BirthdayCleared returns if the "birthday" field was cleared in this mutation.
func (m *UserMutation) BirthdayCleared() bool {
	_, ok := m.clearedFields[user.FieldBirthday]
	return ok
}

// ResetBirthday resets all changes to the "birthday" field.
func (m *UserMutation) ResetBirthday() {
	m.birthday = nil
	delete(m.clearedFields, user.FieldBirthday)
}

// SetIDNumber sets the "id_number" field.
func (m *UserMutation) SetIDNumber(s string) {
	m.id_number = &s
}

// IDNumber returns the value of the "id_number" field in the mutation.
func (m *UserMutation) IDNumber() (r string, exists bool) {
	v := m.id_number
	if v == nil {
		return
	}
	return *v, true
}

// OldIDNumber returns the old "id_number" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldIDNumber(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldIDNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldIDNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIDNumber: %w", err)
	}
	return oldValue.IDNumber, nil
}

// ClearIDNumber clears the value of the "id_number" field.
func (m *UserMutation) ClearIDNumber() {
	m.id_number = nil
	m.clearedFields[user.FieldIDNumber] = struct{}{}
}

// IDNumberCleared returns if the "id_number" field was cleared in this mutation.
func (m *UserMutation) IDNumberCleared() bool {
	_, ok := m.clearedFields[user.FieldIDNumber]
	return ok
}

// ResetIDNumber resets all changes to the "id_number" field.
func (m *UserMutation) ResetIDNumber() {
	m.id_number = nil
	delete(m.clearedFields, user.FieldIDNumber)
}

// SetSex sets the "sex" field.
func (m *UserMutation) SetSex(u user.Sex) {
	m.sex = &u
}

// Sex returns the value of the "sex" field in the mutation.
func (m *UserMutation) Sex() (r user.Sex, exists bool) {
	v := m.sex
	if v == nil {
		return
	}
	return *v, true
}

// OldSex returns the old "sex" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldSex(ctx context.Context) (v *user.Sex, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSex is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSex requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSex: %w", err)
	}
	return oldValue.Sex, nil
}

// ClearSex clears the value of the "sex" field.
func (m *UserMutation) ClearSex() {
	m.sex = nil
	m.clearedFields[user.FieldSex] = struct{}{}
}

// SexCleared returns if the "sex" field was cleared in this mutation.
func (m *UserMutation) SexCleared() bool {
	_, ok := m.clearedFields[user.FieldSex]
	return ok
}

// ResetSex resets all changes to the "sex" field.
func (m *UserMutation) ResetSex() {
	m.sex = nil
	delete(m.clearedFields, user.FieldSex)
}

// SetPhoneNumber sets the "phone_number" field.
func (m *UserMutation) SetPhoneNumber(s string) {
	m.phone_number = &s
}

// PhoneNumber returns the value of the "phone_number" field in the mutation.
func (m *UserMutation) PhoneNumber() (r string, exists bool) {
	v := m.phone_number
	if v == nil {
		return
	}
	return *v, true
}

// OldPhoneNumber returns the old "phone_number" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPhoneNumber(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPhoneNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPhoneNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhoneNumber: %w", err)
	}
	return oldValue.PhoneNumber, nil
}

// ClearPhoneNumber clears the value of the "phone_number" field.
func (m *UserMutation) ClearPhoneNumber() {
	m.phone_number = nil
	m.clearedFields[user.FieldPhoneNumber] = struct{}{}
}

// PhoneNumberCleared returns if the "phone_number" field was cleared in this mutation.
func (m *UserMutation) PhoneNumberCleared() bool {
	_, ok := m.clearedFields[user.FieldPhoneNumber]
	return ok
}

// ResetPhoneNumber resets all changes to the "phone_number" field.
func (m *UserMutation) ResetPhoneNumber() {
	m.phone_number = nil
	delete(m.clearedFields, user.FieldPhoneNumber)
}

// SetAddress sets the "address" field.
func (m *UserMutation) SetAddress(s string) {
	m.address = &s
}

// Address returns the value of the "address" field in the mutation.
func (m *UserMutation) Address() (r string, exists bool) {
	v := m.address
	if v == nil {
		return
	}
	return *v, true
}

// OldAddress returns the old "address" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldAddress(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddress: %w", err)
	}
	return oldValue.Address, nil
}

// ClearAddress clears the value of the "address" field.
func (m *UserMutation) ClearAddress() {
	m.address = nil
	m.clearedFields[user.FieldAddress] = struct{}{}
}

// AddressCleared returns if the "address" field was cleared in this mutation.
func (m *UserMutation) AddressCleared() bool {
	_, ok := m.clearedFields[user.FieldAddress]
	return ok
}

// ResetAddress resets all changes to the "address" field.
func (m *UserMutation) ResetAddress() {
	m.address = nil
	delete(m.clearedFields, user.FieldAddress)
}

// SetStaffID sets the "staff_id" field.
func (m *UserMutation) SetStaffID(s string) {
	m.staff_id = &s
}

// StaffID returns the value of the "staff_id" field in the mutation.
func (m *UserMutation) StaffID() (r string, exists bool) {
	v := m.staff_id
	if v == nil {
		return
	}
	return *v, true
}

// OldStaffID returns the old "staff_id" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldStaffID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStaffID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStaffID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStaffID: %w", err)
	}
	return oldValue.StaffID, nil
}

// ClearStaffID clears the value of the "staff_id" field.
func (m *UserMutation) ClearStaffID() {
	m.staff_id = nil
	m.clearedFields[user.FieldStaffID] = struct{}{}
}

// StaffIDCleared returns if the "staff_id" field was cleared in this mutation.
func (m *UserMutation) StaffIDCleared() bool {
	_, ok := m.clearedFields[user.FieldStaffID]
	return ok
}

// ResetStaffID resets all changes to the "staff_id" field.
func (m *UserMutation) ResetStaffID() {
	m.staff_id = nil
	delete(m.clearedFields, user.FieldStaffID)
}

// SetPersonalEmail sets the "personal_email" field.
func (m *UserMutation) SetPersonalEmail(s string) {
	m.personal_email = &s
}

// PersonalEmail returns the value of the "personal_email" field in the mutation.
func (m *UserMutation) PersonalEmail() (r string, exists bool) {
	v := m.personal_email
	if v == nil {
		return
	}
	return *v, true
}

// OldPersonalEmail returns the old "personal_email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPersonalEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPersonalEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPersonalEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPersonalEmail: %w", err)
	}
	return oldValue.PersonalEmail, nil
}

// ClearPersonalEmail clears the value of the "personal_email" field.
func (m *UserMutation) ClearPersonalEmail() {
	m.personal_email = nil
	m.clearedFields[user.FieldPersonalEmail] = struct{}{}
}

// PersonalEmailCleared returns if the "personal_email" field was cleared in this mutation.
func (m *UserMutation) PersonalEmailCleared() bool {
	_, ok := m.clearedFields[user.FieldPersonalEmail]
	return ok
}

// ResetPersonalEmail resets all changes to the "personal_email" field.
func (m *UserMutation) ResetPersonalEmail() {
	m.personal_email = nil
	delete(m.clearedFields, user.FieldPersonalEmail)
}

// SetIntranetWorkEmail sets the "intranet_work_email" field.
func (m *UserMutation) SetIntranetWorkEmail(s string) {
	m.intranet_work_email = &s
}

// IntranetWorkEmail returns the value of the "intranet_work_email" field in the mutation.
func (m *UserMutation) IntranetWorkEmail() (r string, exists bool) {
	v := m.intranet_work_email
	if v == nil {
		return
	}
	return *v, true
}

// OldIntranetWorkEmail returns the old "intranet_work_email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldIntranetWorkEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldIntranetWorkEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldIntranetWorkEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIntranetWorkEmail: %w", err)
	}
	return oldValue.IntranetWorkEmail, nil
}

// ResetIntranetWorkEmail resets all changes to the "intranet_work_email" field.
func (m *UserMutation) ResetIntranetWorkEmail() {
	m.intranet_work_email = nil
}

// SetExtranetWorkEmail sets the "extranet_work_email" field.
func (m *UserMutation) SetExtranetWorkEmail(s string) {
	m.extranet_work_email = &s
}

// ExtranetWorkEmail returns the value of the "extranet_work_email" field in the mutation.
func (m *UserMutation) ExtranetWorkEmail() (r string, exists bool) {
	v := m.extranet_work_email
	if v == nil {
		return
	}
	return *v, true
}

// OldExtranetWorkEmail returns the old "extranet_work_email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldExtranetWorkEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldExtranetWorkEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldExtranetWorkEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExtranetWorkEmail: %w", err)
	}
	return oldValue.ExtranetWorkEmail, nil
}

// ClearExtranetWorkEmail clears the value of the "extranet_work_email" field.
func (m *UserMutation) ClearExtranetWorkEmail() {
	m.extranet_work_email = nil
	m.clearedFields[user.FieldExtranetWorkEmail] = struct{}{}
}

// ExtranetWorkEmailCleared returns if the "extranet_work_email" field was cleared in this mutation.
func (m *UserMutation) ExtranetWorkEmailCleared() bool {
	_, ok := m.clearedFields[user.FieldExtranetWorkEmail]
	return ok
}

// ResetExtranetWorkEmail resets all changes to the "extranet_work_email" field.
func (m *UserMutation) ResetExtranetWorkEmail() {
	m.extranet_work_email = nil
	delete(m.clearedFields, user.FieldExtranetWorkEmail)
}

// SetCreateByID sets the "create_by" edge to the User entity by id.
func (m *UserMutation) SetCreateByID(id int) {
	m.create_by = &id
}

// ClearCreateBy clears the "create_by" edge to the User entity.
func (m *UserMutation) ClearCreateBy() {
	m.clearedcreate_by = true
}

// CreateByCleared reports if the "create_by" edge to the User entity was cleared.
func (m *UserMutation) CreateByCleared() bool {
	return m.CreateByUserCleared() || m.clearedcreate_by
}

// CreateByID returns the "create_by" edge ID in the mutation.
func (m *UserMutation) CreateByID() (id int, exists bool) {
	if m.create_by != nil {
		return *m.create_by, true
	}
	return
}

// CreateByIDs returns the "create_by" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CreateByID instead. It exists only for internal usage by the builders.
func (m *UserMutation) CreateByIDs() (ids []int) {
	if id := m.create_by; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCreateBy resets all changes to the "create_by" edge.
func (m *UserMutation) ResetCreateBy() {
	m.create_by = nil
	m.clearedcreate_by = false
}

// SetUpdateByID sets the "update_by" edge to the User entity by id.
func (m *UserMutation) SetUpdateByID(id int) {
	m.update_by = &id
}

// ClearUpdateBy clears the "update_by" edge to the User entity.
func (m *UserMutation) ClearUpdateBy() {
	m.clearedupdate_by = true
}

// UpdateByCleared reports if the "update_by" edge to the User entity was cleared.
func (m *UserMutation) UpdateByCleared() bool {
	return m.UpdateByUserCleared() || m.clearedupdate_by
}

// UpdateByID returns the "update_by" edge ID in the mutation.
func (m *UserMutation) UpdateByID() (id int, exists bool) {
	if m.update_by != nil {
		return *m.update_by, true
	}
	return
}

// UpdateByIDs returns the "update_by" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UpdateByID instead. It exists only for internal usage by the builders.
func (m *UserMutation) UpdateByIDs() (ids []int) {
	if id := m.update_by; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUpdateBy resets all changes to the "update_by" edge.
func (m *UserMutation) ResetUpdateBy() {
	m.update_by = nil
	m.clearedupdate_by = false
}

// AddAuthHistoryIDs adds the "authHistories" edge to the Auth entity by ids.
func (m *UserMutation) AddAuthHistoryIDs(ids ...int) {
	if m.authHistories == nil {
		m.authHistories = make(map[int]struct{})
	}
	for i := range ids {
		m.authHistories[ids[i]] = struct{}{}
	}
}

// ClearAuthHistories clears the "authHistories" edge to the Auth entity.
func (m *UserMutation) ClearAuthHistories() {
	m.clearedauthHistories = true
}

// AuthHistoriesCleared reports if the "authHistories" edge to the Auth entity was cleared.
func (m *UserMutation) AuthHistoriesCleared() bool {
	return m.clearedauthHistories
}

// RemoveAuthHistoryIDs removes the "authHistories" edge to the Auth entity by IDs.
func (m *UserMutation) RemoveAuthHistoryIDs(ids ...int) {
	if m.removedauthHistories == nil {
		m.removedauthHistories = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.authHistories, ids[i])
		m.removedauthHistories[ids[i]] = struct{}{}
	}
}

// RemovedAuthHistories returns the removed IDs of the "authHistories" edge to the Auth entity.
func (m *UserMutation) RemovedAuthHistoriesIDs() (ids []int) {
	for id := range m.removedauthHistories {
		ids = append(ids, id)
	}
	return
}

// AuthHistoriesIDs returns the "authHistories" edge IDs in the mutation.
func (m *UserMutation) AuthHistoriesIDs() (ids []int) {
	for id := range m.authHistories {
		ids = append(ids, id)
	}
	return
}

// ResetAuthHistories resets all changes to the "authHistories" edge.
func (m *UserMutation) ResetAuthHistories() {
	m.authHistories = nil
	m.clearedauthHistories = false
	m.removedauthHistories = nil
}

// AddJobHistoryIDs adds the "jobHistories" edge to the JobHistory entity by ids.
func (m *UserMutation) AddJobHistoryIDs(ids ...int) {
	if m.jobHistories == nil {
		m.jobHistories = make(map[int]struct{})
	}
	for i := range ids {
		m.jobHistories[ids[i]] = struct{}{}
	}
}

// ClearJobHistories clears the "jobHistories" edge to the JobHistory entity.
func (m *UserMutation) ClearJobHistories() {
	m.clearedjobHistories = true
}

// JobHistoriesCleared reports if the "jobHistories" edge to the JobHistory entity was cleared.
func (m *UserMutation) JobHistoriesCleared() bool {
	return m.clearedjobHistories
}

// RemoveJobHistoryIDs removes the "jobHistories" edge to the JobHistory entity by IDs.
func (m *UserMutation) RemoveJobHistoryIDs(ids ...int) {
	if m.removedjobHistories == nil {
		m.removedjobHistories = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.jobHistories, ids[i])
		m.removedjobHistories[ids[i]] = struct{}{}
	}
}

// RemovedJobHistories returns the removed IDs of the "jobHistories" edge to the JobHistory entity.
func (m *UserMutation) RemovedJobHistoriesIDs() (ids []int) {
	for id := range m.removedjobHistories {
		ids = append(ids, id)
	}
	return
}

// JobHistoriesIDs returns the "jobHistories" edge IDs in the mutation.
func (m *UserMutation) JobHistoriesIDs() (ids []int) {
	for id := range m.jobHistories {
		ids = append(ids, id)
	}
	return
}

// ResetJobHistories resets all changes to the "jobHistories" edge.
func (m *UserMutation) ResetJobHistories() {
	m.jobHistories = nil
	m.clearedjobHistories = false
	m.removedjobHistories = nil
}

// AddCreateIDs adds the "creates" edge to the User entity by ids.
func (m *UserMutation) AddCreateIDs(ids ...int) {
	if m.creates == nil {
		m.creates = make(map[int]struct{})
	}
	for i := range ids {
		m.creates[ids[i]] = struct{}{}
	}
}

// ClearCreates clears the "creates" edge to the User entity.
func (m *UserMutation) ClearCreates() {
	m.clearedcreates = true
}

// CreatesCleared reports if the "creates" edge to the User entity was cleared.
func (m *UserMutation) CreatesCleared() bool {
	return m.clearedcreates
}

// RemoveCreateIDs removes the "creates" edge to the User entity by IDs.
func (m *UserMutation) RemoveCreateIDs(ids ...int) {
	if m.removedcreates == nil {
		m.removedcreates = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.creates, ids[i])
		m.removedcreates[ids[i]] = struct{}{}
	}
}

// RemovedCreates returns the removed IDs of the "creates" edge to the User entity.
func (m *UserMutation) RemovedCreatesIDs() (ids []int) {
	for id := range m.removedcreates {
		ids = append(ids, id)
	}
	return
}

// CreatesIDs returns the "creates" edge IDs in the mutation.
func (m *UserMutation) CreatesIDs() (ids []int) {
	for id := range m.creates {
		ids = append(ids, id)
	}
	return
}

// ResetCreates resets all changes to the "creates" edge.
func (m *UserMutation) ResetCreates() {
	m.creates = nil
	m.clearedcreates = false
	m.removedcreates = nil
}

// AddUpdateIDs adds the "updates" edge to the User entity by ids.
func (m *UserMutation) AddUpdateIDs(ids ...int) {
	if m.updates == nil {
		m.updates = make(map[int]struct{})
	}
	for i := range ids {
		m.updates[ids[i]] = struct{}{}
	}
}

// ClearUpdates clears the "updates" edge to the User entity.
func (m *UserMutation) ClearUpdates() {
	m.clearedupdates = true
}

// UpdatesCleared reports if the "updates" edge to the User entity was cleared.
func (m *UserMutation) UpdatesCleared() bool {
	return m.clearedupdates
}

// RemoveUpdateIDs removes the "updates" edge to the User entity by IDs.
func (m *UserMutation) RemoveUpdateIDs(ids ...int) {
	if m.removedupdates == nil {
		m.removedupdates = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.updates, ids[i])
		m.removedupdates[ids[i]] = struct{}{}
	}
}

// RemovedUpdates returns the removed IDs of the "updates" edge to the User entity.
func (m *UserMutation) RemovedUpdatesIDs() (ids []int) {
	for id := range m.removedupdates {
		ids = append(ids, id)
	}
	return
}

// UpdatesIDs returns the "updates" edge IDs in the mutation.
func (m *UserMutation) UpdatesIDs() (ids []int) {
	for id := range m.updates {
		ids = append(ids, id)
	}
	return
}

// ResetUpdates resets all changes to the "updates" edge.
func (m *UserMutation) ResetUpdates() {
	m.updates = nil
	m.clearedupdates = false
	m.removedupdates = nil
}

// AddBelongToOrgUnitMemberIDs adds the "belongToOrgUnitMembers" edge to the OrgUnitMember entity by ids.
func (m *UserMutation) AddBelongToOrgUnitMemberIDs(ids ...int) {
	if m.belongToOrgUnitMembers == nil {
		m.belongToOrgUnitMembers = make(map[int]struct{})
	}
	for i := range ids {
		m.belongToOrgUnitMembers[ids[i]] = struct{}{}
	}
}

// ClearBelongToOrgUnitMembers clears the "belongToOrgUnitMembers" edge to the OrgUnitMember entity.
func (m *UserMutation) ClearBelongToOrgUnitMembers() {
	m.clearedbelongToOrgUnitMembers = true
}

// BelongToOrgUnitMembersCleared reports if the "belongToOrgUnitMembers" edge to the OrgUnitMember entity was cleared.
func (m *UserMutation) BelongToOrgUnitMembersCleared() bool {
	return m.clearedbelongToOrgUnitMembers
}

// RemoveBelongToOrgUnitMemberIDs removes the "belongToOrgUnitMembers" edge to the OrgUnitMember entity by IDs.
func (m *UserMutation) RemoveBelongToOrgUnitMemberIDs(ids ...int) {
	if m.removedbelongToOrgUnitMembers == nil {
		m.removedbelongToOrgUnitMembers = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.belongToOrgUnitMembers, ids[i])
		m.removedbelongToOrgUnitMembers[ids[i]] = struct{}{}
	}
}

// RemovedBelongToOrgUnitMembers returns the removed IDs of the "belongToOrgUnitMembers" edge to the OrgUnitMember entity.
func (m *UserMutation) RemovedBelongToOrgUnitMembersIDs() (ids []int) {
	for id := range m.removedbelongToOrgUnitMembers {
		ids = append(ids, id)
	}
	return
}

// BelongToOrgUnitMembersIDs returns the "belongToOrgUnitMembers" edge IDs in the mutation.
func (m *UserMutation) BelongToOrgUnitMembersIDs() (ids []int) {
	for id := range m.belongToOrgUnitMembers {
		ids = append(ids, id)
	}
	return
}

// ResetBelongToOrgUnitMembers resets all changes to the "belongToOrgUnitMembers" edge.
func (m *UserMutation) ResetBelongToOrgUnitMembers() {
	m.belongToOrgUnitMembers = nil
	m.clearedbelongToOrgUnitMembers = false
	m.removedbelongToOrgUnitMembers = nil
}

// AddBelongToOgIDs adds the "belongToOg" edge to the Organization entity by ids.
func (m *UserMutation) AddBelongToOgIDs(ids ...int) {
	if m.belongToOg == nil {
		m.belongToOg = make(map[int]struct{})
	}
	for i := range ids {
		m.belongToOg[ids[i]] = struct{}{}
	}
}

// ClearBelongToOg clears the "belongToOg" edge to the Organization entity.
func (m *UserMutation) ClearBelongToOg() {
	m.clearedbelongToOg = true
}

// BelongToOgCleared reports if the "belongToOg" edge to the Organization entity was cleared.
func (m *UserMutation) BelongToOgCleared() bool {
	return m.clearedbelongToOg
}

// RemoveBelongToOgIDs removes the "belongToOg" edge to the Organization entity by IDs.
func (m *UserMutation) RemoveBelongToOgIDs(ids ...int) {
	if m.removedbelongToOg == nil {
		m.removedbelongToOg = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.belongToOg, ids[i])
		m.removedbelongToOg[ids[i]] = struct{}{}
	}
}

// RemovedBelongToOg returns the removed IDs of the "belongToOg" edge to the Organization entity.
func (m *UserMutation) RemovedBelongToOgIDs() (ids []int) {
	for id := range m.removedbelongToOg {
		ids = append(ids, id)
	}
	return
}

// BelongToOgIDs returns the "belongToOg" edge IDs in the mutation.
func (m *UserMutation) BelongToOgIDs() (ids []int) {
	for id := range m.belongToOg {
		ids = append(ids, id)
	}
	return
}

// ResetBelongToOg resets all changes to the "belongToOg" edge.
func (m *UserMutation) ResetBelongToOg() {
	m.belongToOg = nil
	m.clearedbelongToOg = false
	m.removedbelongToOg = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 19)
	if m.create_by != nil {
		fields = append(fields, user.FieldCreateByUser)
	}
	if m.update_by != nil {
		fields = append(fields, user.FieldUpdateByUser)
	}
	if m.create_time != nil {
		fields = append(fields, user.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, user.FieldUpdateTime)
	}
	if m.account_name != nil {
		fields = append(fields, user.FieldAccountName)
	}
	if m.staff_type != nil {
		fields = append(fields, user.FieldStaffType)
	}
	if m.is_on_job != nil {
		fields = append(fields, user.FieldIsOnJob)
	}
	if m.family_name != nil {
		fields = append(fields, user.FieldFamilyName)
	}
	if m.given_name != nil {
		fields = append(fields, user.FieldGivenName)
	}
	if m.display_name != nil {
		fields = append(fields, user.FieldDisplayName)
	}
	if m.birthday != nil {
		fields = append(fields, user.FieldBirthday)
	}
	if m.id_number != nil {
		fields = append(fields, user.FieldIDNumber)
	}
	if m.sex != nil {
		fields = append(fields, user.FieldSex)
	}
	if m.phone_number != nil {
		fields = append(fields, user.FieldPhoneNumber)
	}
	if m.address != nil {
		fields = append(fields, user.FieldAddress)
	}
	if m.staff_id != nil {
		fields = append(fields, user.FieldStaffID)
	}
	if m.personal_email != nil {
		fields = append(fields, user.FieldPersonalEmail)
	}
	if m.intranet_work_email != nil {
		fields = append(fields, user.FieldIntranetWorkEmail)
	}
	if m.extranet_work_email != nil {
		fields = append(fields, user.FieldExtranetWorkEmail)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldCreateByUser:
		return m.CreateByUser()
	case user.FieldUpdateByUser:
		return m.UpdateByUser()
	case user.FieldCreateTime:
		return m.CreateTime()
	case user.FieldUpdateTime:
		return m.UpdateTime()
	case user.FieldAccountName:
		return m.AccountName()
	case user.FieldStaffType:
		return m.StaffType()
	case user.FieldIsOnJob:
		return m.IsOnJob()
	case user.FieldFamilyName:
		return m.FamilyName()
	case user.FieldGivenName:
		return m.GivenName()
	case user.FieldDisplayName:
		return m.DisplayName()
	case user.FieldBirthday:
		return m.Birthday()
	case user.FieldIDNumber:
		return m.IDNumber()
	case user.FieldSex:
		return m.Sex()
	case user.FieldPhoneNumber:
		return m.PhoneNumber()
	case user.FieldAddress:
		return m.Address()
	case user.FieldStaffID:
		return m.StaffID()
	case user.FieldPersonalEmail:
		return m.PersonalEmail()
	case user.FieldIntranetWorkEmail:
		return m.IntranetWorkEmail()
	case user.FieldExtranetWorkEmail:
		return m.ExtranetWorkEmail()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldCreateByUser:
		return m.OldCreateByUser(ctx)
	case user.FieldUpdateByUser:
		return m.OldUpdateByUser(ctx)
	case user.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case user.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case user.FieldAccountName:
		return m.OldAccountName(ctx)
	case user.FieldStaffType:
		return m.OldStaffType(ctx)
	case user.FieldIsOnJob:
		return m.OldIsOnJob(ctx)
	case user.FieldFamilyName:
		return m.OldFamilyName(ctx)
	case user.FieldGivenName:
		return m.OldGivenName(ctx)
	case user.FieldDisplayName:
		return m.OldDisplayName(ctx)
	case user.FieldBirthday:
		return m.OldBirthday(ctx)
	case user.FieldIDNumber:
		return m.OldIDNumber(ctx)
	case user.FieldSex:
		return m.OldSex(ctx)
	case user.FieldPhoneNumber:
		return m.OldPhoneNumber(ctx)
	case user.FieldAddress:
		return m.OldAddress(ctx)
	case user.FieldStaffID:
		return m.OldStaffID(ctx)
	case user.FieldPersonalEmail:
		return m.OldPersonalEmail(ctx)
	case user.FieldIntranetWorkEmail:
		return m.OldIntranetWorkEmail(ctx)
	case user.FieldExtranetWorkEmail:
		return m.OldExtranetWorkEmail(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldCreateByUser:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateByUser(v)
		return nil
	case user.FieldUpdateByUser:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateByUser(v)
		return nil
	case user.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case user.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case user.FieldAccountName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccountName(v)
		return nil
	case user.FieldStaffType:
		v, ok := value.(user.StaffType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStaffType(v)
		return nil
	case user.FieldIsOnJob:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsOnJob(v)
		return nil
	case user.FieldFamilyName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFamilyName(v)
		return nil
	case user.FieldGivenName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGivenName(v)
		return nil
	case user.FieldDisplayName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayName(v)
		return nil
	case user.FieldBirthday:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBirthday(v)
		return nil
	case user.FieldIDNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIDNumber(v)
		return nil
	case user.FieldSex:
		v, ok := value.(user.Sex)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSex(v)
		return nil
	case user.FieldPhoneNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhoneNumber(v)
		return nil
	case user.FieldAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddress(v)
		return nil
	case user.FieldStaffID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStaffID(v)
		return nil
	case user.FieldPersonalEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPersonalEmail(v)
		return nil
	case user.FieldIntranetWorkEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIntranetWorkEmail(v)
		return nil
	case user.FieldExtranetWorkEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExtranetWorkEmail(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(user.FieldCreateByUser) {
		fields = append(fields, user.FieldCreateByUser)
	}
	if m.FieldCleared(user.FieldUpdateByUser) {
		fields = append(fields, user.FieldUpdateByUser)
	}
	if m.FieldCleared(user.FieldUpdateTime) {
		fields = append(fields, user.FieldUpdateTime)
	}
	if m.FieldCleared(user.FieldBirthday) {
		fields = append(fields, user.FieldBirthday)
	}
	if m.FieldCleared(user.FieldIDNumber) {
		fields = append(fields, user.FieldIDNumber)
	}
	if m.FieldCleared(user.FieldSex) {
		fields = append(fields, user.FieldSex)
	}
	if m.FieldCleared(user.FieldPhoneNumber) {
		fields = append(fields, user.FieldPhoneNumber)
	}
	if m.FieldCleared(user.FieldAddress) {
		fields = append(fields, user.FieldAddress)
	}
	if m.FieldCleared(user.FieldStaffID) {
		fields = append(fields, user.FieldStaffID)
	}
	if m.FieldCleared(user.FieldPersonalEmail) {
		fields = append(fields, user.FieldPersonalEmail)
	}
	if m.FieldCleared(user.FieldExtranetWorkEmail) {
		fields = append(fields, user.FieldExtranetWorkEmail)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	switch name {
	case user.FieldCreateByUser:
		m.ClearCreateByUser()
		return nil
	case user.FieldUpdateByUser:
		m.ClearUpdateByUser()
		return nil
	case user.FieldUpdateTime:
		m.ClearUpdateTime()
		return nil
	case user.FieldBirthday:
		m.ClearBirthday()
		return nil
	case user.FieldIDNumber:
		m.ClearIDNumber()
		return nil
	case user.FieldSex:
		m.ClearSex()
		return nil
	case user.FieldPhoneNumber:
		m.ClearPhoneNumber()
		return nil
	case user.FieldAddress:
		m.ClearAddress()
		return nil
	case user.FieldStaffID:
		m.ClearStaffID()
		return nil
	case user.FieldPersonalEmail:
		m.ClearPersonalEmail()
		return nil
	case user.FieldExtranetWorkEmail:
		m.ClearExtranetWorkEmail()
		return nil
	}
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldCreateByUser:
		m.ResetCreateByUser()
		return nil
	case user.FieldUpdateByUser:
		m.ResetUpdateByUser()
		return nil
	case user.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case user.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case user.FieldAccountName:
		m.ResetAccountName()
		return nil
	case user.FieldStaffType:
		m.ResetStaffType()
		return nil
	case user.FieldIsOnJob:
		m.ResetIsOnJob()
		return nil
	case user.FieldFamilyName:
		m.ResetFamilyName()
		return nil
	case user.FieldGivenName:
		m.ResetGivenName()
		return nil
	case user.FieldDisplayName:
		m.ResetDisplayName()
		return nil
	case user.FieldBirthday:
		m.ResetBirthday()
		return nil
	case user.FieldIDNumber:
		m.ResetIDNumber()
		return nil
	case user.FieldSex:
		m.ResetSex()
		return nil
	case user.FieldPhoneNumber:
		m.ResetPhoneNumber()
		return nil
	case user.FieldAddress:
		m.ResetAddress()
		return nil
	case user.FieldStaffID:
		m.ResetStaffID()
		return nil
	case user.FieldPersonalEmail:
		m.ResetPersonalEmail()
		return nil
	case user.FieldIntranetWorkEmail:
		m.ResetIntranetWorkEmail()
		return nil
	case user.FieldExtranetWorkEmail:
		m.ResetExtranetWorkEmail()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 8)
	if m.create_by != nil {
		edges = append(edges, user.EdgeCreateBy)
	}
	if m.update_by != nil {
		edges = append(edges, user.EdgeUpdateBy)
	}
	if m.authHistories != nil {
		edges = append(edges, user.EdgeAuthHistories)
	}
	if m.jobHistories != nil {
		edges = append(edges, user.EdgeJobHistories)
	}
	if m.creates != nil {
		edges = append(edges, user.EdgeCreates)
	}
	if m.updates != nil {
		edges = append(edges, user.EdgeUpdates)
	}
	if m.belongToOrgUnitMembers != nil {
		edges = append(edges, user.EdgeBelongToOrgUnitMembers)
	}
	if m.belongToOg != nil {
		edges = append(edges, user.EdgeBelongToOg)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeCreateBy:
		if id := m.create_by; id != nil {
			return []ent.Value{*id}
		}
	case user.EdgeUpdateBy:
		if id := m.update_by; id != nil {
			return []ent.Value{*id}
		}
	case user.EdgeAuthHistories:
		ids := make([]ent.Value, 0, len(m.authHistories))
		for id := range m.authHistories {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeJobHistories:
		ids := make([]ent.Value, 0, len(m.jobHistories))
		for id := range m.jobHistories {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCreates:
		ids := make([]ent.Value, 0, len(m.creates))
		for id := range m.creates {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeUpdates:
		ids := make([]ent.Value, 0, len(m.updates))
		for id := range m.updates {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeBelongToOrgUnitMembers:
		ids := make([]ent.Value, 0, len(m.belongToOrgUnitMembers))
		for id := range m.belongToOrgUnitMembers {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeBelongToOg:
		ids := make([]ent.Value, 0, len(m.belongToOg))
		for id := range m.belongToOg {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 8)
	if m.removedauthHistories != nil {
		edges = append(edges, user.EdgeAuthHistories)
	}
	if m.removedjobHistories != nil {
		edges = append(edges, user.EdgeJobHistories)
	}
	if m.removedcreates != nil {
		edges = append(edges, user.EdgeCreates)
	}
	if m.removedupdates != nil {
		edges = append(edges, user.EdgeUpdates)
	}
	if m.removedbelongToOrgUnitMembers != nil {
		edges = append(edges, user.EdgeBelongToOrgUnitMembers)
	}
	if m.removedbelongToOg != nil {
		edges = append(edges, user.EdgeBelongToOg)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeAuthHistories:
		ids := make([]ent.Value, 0, len(m.removedauthHistories))
		for id := range m.removedauthHistories {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeJobHistories:
		ids := make([]ent.Value, 0, len(m.removedjobHistories))
		for id := range m.removedjobHistories {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCreates:
		ids := make([]ent.Value, 0, len(m.removedcreates))
		for id := range m.removedcreates {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeUpdates:
		ids := make([]ent.Value, 0, len(m.removedupdates))
		for id := range m.removedupdates {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeBelongToOrgUnitMembers:
		ids := make([]ent.Value, 0, len(m.removedbelongToOrgUnitMembers))
		for id := range m.removedbelongToOrgUnitMembers {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeBelongToOg:
		ids := make([]ent.Value, 0, len(m.removedbelongToOg))
		for id := range m.removedbelongToOg {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 8)
	if m.clearedcreate_by {
		edges = append(edges, user.EdgeCreateBy)
	}
	if m.clearedupdate_by {
		edges = append(edges, user.EdgeUpdateBy)
	}
	if m.clearedauthHistories {
		edges = append(edges, user.EdgeAuthHistories)
	}
	if m.clearedjobHistories {
		edges = append(edges, user.EdgeJobHistories)
	}
	if m.clearedcreates {
		edges = append(edges, user.EdgeCreates)
	}
	if m.clearedupdates {
		edges = append(edges, user.EdgeUpdates)
	}
	if m.clearedbelongToOrgUnitMembers {
		edges = append(edges, user.EdgeBelongToOrgUnitMembers)
	}
	if m.clearedbelongToOg {
		edges = append(edges, user.EdgeBelongToOg)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeCreateBy:
		return m.clearedcreate_by
	case user.EdgeUpdateBy:
		return m.clearedupdate_by
	case user.EdgeAuthHistories:
		return m.clearedauthHistories
	case user.EdgeJobHistories:
		return m.clearedjobHistories
	case user.EdgeCreates:
		return m.clearedcreates
	case user.EdgeUpdates:
		return m.clearedupdates
	case user.EdgeBelongToOrgUnitMembers:
		return m.clearedbelongToOrgUnitMembers
	case user.EdgeBelongToOg:
		return m.clearedbelongToOg
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	case user.EdgeCreateBy:
		m.ClearCreateBy()
		return nil
	case user.EdgeUpdateBy:
		m.ClearUpdateBy()
		return nil
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeCreateBy:
		m.ResetCreateBy()
		return nil
	case user.EdgeUpdateBy:
		m.ResetUpdateBy()
		return nil
	case user.EdgeAuthHistories:
		m.ResetAuthHistories()
		return nil
	case user.EdgeJobHistories:
		m.ResetJobHistories()
		return nil
	case user.EdgeCreates:
		m.ResetCreates()
		return nil
	case user.EdgeUpdates:
		m.ResetUpdates()
		return nil
	case user.EdgeBelongToOrgUnitMembers:
		m.ResetBelongToOrgUnitMembers()
		return nil
	case user.EdgeBelongToOg:
		m.ResetBelongToOg()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}
