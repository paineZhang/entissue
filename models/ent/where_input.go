// Code generated by entc, DO NOT EDIT.

package ent

import (
	"fmt"
	"time"
	"wing/models/ent/auth"
	"wing/models/ent/jobhistory"
	"wing/models/ent/organization"
	"wing/models/ent/orgunit"
	"wing/models/ent/orgunitmember"
	"wing/models/ent/orgunitposition"
	"wing/models/ent/predicate"
	"wing/models/ent/resource"
	"wing/models/ent/system"
	"wing/models/ent/user"
)

// AuthWhereInput represents a where input for filtering Auth queries.
type AuthWhereInput struct {
	Not *AuthWhereInput   `json:"not,omitempty"`
	Or  []*AuthWhereInput `json:"or,omitempty"`
	And []*AuthWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "last_auth_time" field predicates.
	LastAuthTime      *time.Time  `json:"lastAuthTime,omitempty"`
	LastAuthTimeNEQ   *time.Time  `json:"lastAuthTimeNEQ,omitempty"`
	LastAuthTimeIn    []time.Time `json:"lastAuthTimeIn,omitempty"`
	LastAuthTimeNotIn []time.Time `json:"lastAuthTimeNotIn,omitempty"`
	LastAuthTimeGT    *time.Time  `json:"lastAuthTimeGT,omitempty"`
	LastAuthTimeGTE   *time.Time  `json:"lastAuthTimeGTE,omitempty"`
	LastAuthTimeLT    *time.Time  `json:"lastAuthTimeLT,omitempty"`
	LastAuthTimeLTE   *time.Time  `json:"lastAuthTimeLTE,omitempty"`

	// "auth_type" field predicates.
	AuthType      *auth.AuthType  `json:"authType,omitempty"`
	AuthTypeNEQ   *auth.AuthType  `json:"authTypeNEQ,omitempty"`
	AuthTypeIn    []auth.AuthType `json:"authTypeIn,omitempty"`
	AuthTypeNotIn []auth.AuthType `json:"authTypeNotIn,omitempty"`

	// "belong_to" edge predicates.
	HasBelongTo     *bool             `json:"hasBelongTo,omitempty"`
	HasBelongToWith []*UserWhereInput `json:"hasBelongToWith,omitempty"`
}

// Filter applies the AuthWhereInput filter on the AuthQuery builder.
func (i *AuthWhereInput) Filter(q *AuthQuery) (*AuthQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		return nil, err
	}
	return q.Where(p), nil
}

// P returns a predicate for filtering auths.
// An error is returned if the input is empty or invalid.
func (i *AuthWhereInput) P() (predicate.Auth, error) {
	var predicates []predicate.Auth
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, auth.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Auth, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			or = append(or, p)
		}
		predicates = append(predicates, auth.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Auth, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			and = append(and, p)
		}
		predicates = append(predicates, auth.And(and...))
	}
	if i.ID != nil {
		predicates = append(predicates, auth.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, auth.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, auth.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, auth.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, auth.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, auth.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, auth.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, auth.IDLTE(*i.IDLTE))
	}
	if i.LastAuthTime != nil {
		predicates = append(predicates, auth.LastAuthTimeEQ(*i.LastAuthTime))
	}
	if i.LastAuthTimeNEQ != nil {
		predicates = append(predicates, auth.LastAuthTimeNEQ(*i.LastAuthTimeNEQ))
	}
	if len(i.LastAuthTimeIn) > 0 {
		predicates = append(predicates, auth.LastAuthTimeIn(i.LastAuthTimeIn...))
	}
	if len(i.LastAuthTimeNotIn) > 0 {
		predicates = append(predicates, auth.LastAuthTimeNotIn(i.LastAuthTimeNotIn...))
	}
	if i.LastAuthTimeGT != nil {
		predicates = append(predicates, auth.LastAuthTimeGT(*i.LastAuthTimeGT))
	}
	if i.LastAuthTimeGTE != nil {
		predicates = append(predicates, auth.LastAuthTimeGTE(*i.LastAuthTimeGTE))
	}
	if i.LastAuthTimeLT != nil {
		predicates = append(predicates, auth.LastAuthTimeLT(*i.LastAuthTimeLT))
	}
	if i.LastAuthTimeLTE != nil {
		predicates = append(predicates, auth.LastAuthTimeLTE(*i.LastAuthTimeLTE))
	}
	if i.AuthType != nil {
		predicates = append(predicates, auth.AuthTypeEQ(*i.AuthType))
	}
	if i.AuthTypeNEQ != nil {
		predicates = append(predicates, auth.AuthTypeNEQ(*i.AuthTypeNEQ))
	}
	if len(i.AuthTypeIn) > 0 {
		predicates = append(predicates, auth.AuthTypeIn(i.AuthTypeIn...))
	}
	if len(i.AuthTypeNotIn) > 0 {
		predicates = append(predicates, auth.AuthTypeNotIn(i.AuthTypeNotIn...))
	}

	if i.HasBelongTo != nil {
		p := auth.HasBelongTo()
		if !*i.HasBelongTo {
			p = auth.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasBelongToWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasBelongToWith))
		for _, w := range i.HasBelongToWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, auth.HasBelongToWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, fmt.Errorf("wing/models/ent: empty predicate AuthWhereInput")
	case 1:
		return predicates[0], nil
	default:
		return auth.And(predicates...), nil
	}
}

// JobHistoryWhereInput represents a where input for filtering JobHistory queries.
type JobHistoryWhereInput struct {
	Not *JobHistoryWhereInput   `json:"not,omitempty"`
	Or  []*JobHistoryWhereInput `json:"or,omitempty"`
	And []*JobHistoryWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "create_by_user" field predicates.
	CreateByUser       *int  `json:"createByUser,omitempty"`
	CreateByUserNEQ    *int  `json:"createByUserNEQ,omitempty"`
	CreateByUserIn     []int `json:"createByUserIn,omitempty"`
	CreateByUserNotIn  []int `json:"createByUserNotIn,omitempty"`
	CreateByUserIsNil  bool  `json:"createByUserIsNil,omitempty"`
	CreateByUserNotNil bool  `json:"createByUserNotNil,omitempty"`

	// "create_time" field predicates.
	CreateTime      *time.Time  `json:"createTime,omitempty"`
	CreateTimeNEQ   *time.Time  `json:"createTimeNEQ,omitempty"`
	CreateTimeIn    []time.Time `json:"createTimeIn,omitempty"`
	CreateTimeNotIn []time.Time `json:"createTimeNotIn,omitempty"`
	CreateTimeGT    *time.Time  `json:"createTimeGT,omitempty"`
	CreateTimeGTE   *time.Time  `json:"createTimeGTE,omitempty"`
	CreateTimeLT    *time.Time  `json:"createTimeLT,omitempty"`
	CreateTimeLTE   *time.Time  `json:"createTimeLTE,omitempty"`

	// "date" field predicates.
	Date      *time.Time  `json:"date,omitempty"`
	DateNEQ   *time.Time  `json:"dateNEQ,omitempty"`
	DateIn    []time.Time `json:"dateIn,omitempty"`
	DateNotIn []time.Time `json:"dateNotIn,omitempty"`
	DateGT    *time.Time  `json:"dateGT,omitempty"`
	DateGTE   *time.Time  `json:"dateGTE,omitempty"`
	DateLT    *time.Time  `json:"dateLT,omitempty"`
	DateLTE   *time.Time  `json:"dateLTE,omitempty"`

	// "job_entry_leave_type" field predicates.
	JobEntryLeaveType      *jobhistory.JobEntryLeaveType  `json:"jobEntryLeaveType,omitempty"`
	JobEntryLeaveTypeNEQ   *jobhistory.JobEntryLeaveType  `json:"jobEntryLeaveTypeNEQ,omitempty"`
	JobEntryLeaveTypeIn    []jobhistory.JobEntryLeaveType `json:"jobEntryLeaveTypeIn,omitempty"`
	JobEntryLeaveTypeNotIn []jobhistory.JobEntryLeaveType `json:"jobEntryLeaveTypeNotIn,omitempty"`

	// "create_by" edge predicates.
	HasCreateBy     *bool             `json:"hasCreateBy,omitempty"`
	HasCreateByWith []*UserWhereInput `json:"hasCreateByWith,omitempty"`

	// "belong_to" edge predicates.
	HasBelongTo     *bool             `json:"hasBelongTo,omitempty"`
	HasBelongToWith []*UserWhereInput `json:"hasBelongToWith,omitempty"`
}

// Filter applies the JobHistoryWhereInput filter on the JobHistoryQuery builder.
func (i *JobHistoryWhereInput) Filter(q *JobHistoryQuery) (*JobHistoryQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		return nil, err
	}
	return q.Where(p), nil
}

// P returns a predicate for filtering jobhistories.
// An error is returned if the input is empty or invalid.
func (i *JobHistoryWhereInput) P() (predicate.JobHistory, error) {
	var predicates []predicate.JobHistory
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, jobhistory.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.JobHistory, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			or = append(or, p)
		}
		predicates = append(predicates, jobhistory.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.JobHistory, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			and = append(and, p)
		}
		predicates = append(predicates, jobhistory.And(and...))
	}
	if i.ID != nil {
		predicates = append(predicates, jobhistory.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, jobhistory.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, jobhistory.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, jobhistory.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, jobhistory.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, jobhistory.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, jobhistory.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, jobhistory.IDLTE(*i.IDLTE))
	}
	if i.CreateByUser != nil {
		predicates = append(predicates, jobhistory.CreateByUserEQ(*i.CreateByUser))
	}
	if i.CreateByUserNEQ != nil {
		predicates = append(predicates, jobhistory.CreateByUserNEQ(*i.CreateByUserNEQ))
	}
	if len(i.CreateByUserIn) > 0 {
		predicates = append(predicates, jobhistory.CreateByUserIn(i.CreateByUserIn...))
	}
	if len(i.CreateByUserNotIn) > 0 {
		predicates = append(predicates, jobhistory.CreateByUserNotIn(i.CreateByUserNotIn...))
	}
	if i.CreateByUserIsNil {
		predicates = append(predicates, jobhistory.CreateByUserIsNil())
	}
	if i.CreateByUserNotNil {
		predicates = append(predicates, jobhistory.CreateByUserNotNil())
	}
	if i.CreateTime != nil {
		predicates = append(predicates, jobhistory.CreateTimeEQ(*i.CreateTime))
	}
	if i.CreateTimeNEQ != nil {
		predicates = append(predicates, jobhistory.CreateTimeNEQ(*i.CreateTimeNEQ))
	}
	if len(i.CreateTimeIn) > 0 {
		predicates = append(predicates, jobhistory.CreateTimeIn(i.CreateTimeIn...))
	}
	if len(i.CreateTimeNotIn) > 0 {
		predicates = append(predicates, jobhistory.CreateTimeNotIn(i.CreateTimeNotIn...))
	}
	if i.CreateTimeGT != nil {
		predicates = append(predicates, jobhistory.CreateTimeGT(*i.CreateTimeGT))
	}
	if i.CreateTimeGTE != nil {
		predicates = append(predicates, jobhistory.CreateTimeGTE(*i.CreateTimeGTE))
	}
	if i.CreateTimeLT != nil {
		predicates = append(predicates, jobhistory.CreateTimeLT(*i.CreateTimeLT))
	}
	if i.CreateTimeLTE != nil {
		predicates = append(predicates, jobhistory.CreateTimeLTE(*i.CreateTimeLTE))
	}
	if i.Date != nil {
		predicates = append(predicates, jobhistory.DateEQ(*i.Date))
	}
	if i.DateNEQ != nil {
		predicates = append(predicates, jobhistory.DateNEQ(*i.DateNEQ))
	}
	if len(i.DateIn) > 0 {
		predicates = append(predicates, jobhistory.DateIn(i.DateIn...))
	}
	if len(i.DateNotIn) > 0 {
		predicates = append(predicates, jobhistory.DateNotIn(i.DateNotIn...))
	}
	if i.DateGT != nil {
		predicates = append(predicates, jobhistory.DateGT(*i.DateGT))
	}
	if i.DateGTE != nil {
		predicates = append(predicates, jobhistory.DateGTE(*i.DateGTE))
	}
	if i.DateLT != nil {
		predicates = append(predicates, jobhistory.DateLT(*i.DateLT))
	}
	if i.DateLTE != nil {
		predicates = append(predicates, jobhistory.DateLTE(*i.DateLTE))
	}
	if i.JobEntryLeaveType != nil {
		predicates = append(predicates, jobhistory.JobEntryLeaveTypeEQ(*i.JobEntryLeaveType))
	}
	if i.JobEntryLeaveTypeNEQ != nil {
		predicates = append(predicates, jobhistory.JobEntryLeaveTypeNEQ(*i.JobEntryLeaveTypeNEQ))
	}
	if len(i.JobEntryLeaveTypeIn) > 0 {
		predicates = append(predicates, jobhistory.JobEntryLeaveTypeIn(i.JobEntryLeaveTypeIn...))
	}
	if len(i.JobEntryLeaveTypeNotIn) > 0 {
		predicates = append(predicates, jobhistory.JobEntryLeaveTypeNotIn(i.JobEntryLeaveTypeNotIn...))
	}

	if i.HasCreateBy != nil {
		p := jobhistory.HasCreateBy()
		if !*i.HasCreateBy {
			p = jobhistory.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCreateByWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasCreateByWith))
		for _, w := range i.HasCreateByWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, jobhistory.HasCreateByWith(with...))
	}
	if i.HasBelongTo != nil {
		p := jobhistory.HasBelongTo()
		if !*i.HasBelongTo {
			p = jobhistory.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasBelongToWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasBelongToWith))
		for _, w := range i.HasBelongToWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, jobhistory.HasBelongToWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, fmt.Errorf("wing/models/ent: empty predicate JobHistoryWhereInput")
	case 1:
		return predicates[0], nil
	default:
		return jobhistory.And(predicates...), nil
	}
}

// OrgUnitWhereInput represents a where input for filtering OrgUnit queries.
type OrgUnitWhereInput struct {
	Not *OrgUnitWhereInput   `json:"not,omitempty"`
	Or  []*OrgUnitWhereInput `json:"or,omitempty"`
	And []*OrgUnitWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "create_by_user" field predicates.
	CreateByUser       *int  `json:"createByUser,omitempty"`
	CreateByUserNEQ    *int  `json:"createByUserNEQ,omitempty"`
	CreateByUserIn     []int `json:"createByUserIn,omitempty"`
	CreateByUserNotIn  []int `json:"createByUserNotIn,omitempty"`
	CreateByUserIsNil  bool  `json:"createByUserIsNil,omitempty"`
	CreateByUserNotNil bool  `json:"createByUserNotNil,omitempty"`

	// "update_by_user" field predicates.
	UpdateByUser       *int  `json:"updateByUser,omitempty"`
	UpdateByUserNEQ    *int  `json:"updateByUserNEQ,omitempty"`
	UpdateByUserIn     []int `json:"updateByUserIn,omitempty"`
	UpdateByUserNotIn  []int `json:"updateByUserNotIn,omitempty"`
	UpdateByUserIsNil  bool  `json:"updateByUserIsNil,omitempty"`
	UpdateByUserNotNil bool  `json:"updateByUserNotNil,omitempty"`

	// "create_time" field predicates.
	CreateTime      *time.Time  `json:"createTime,omitempty"`
	CreateTimeNEQ   *time.Time  `json:"createTimeNEQ,omitempty"`
	CreateTimeIn    []time.Time `json:"createTimeIn,omitempty"`
	CreateTimeNotIn []time.Time `json:"createTimeNotIn,omitempty"`
	CreateTimeGT    *time.Time  `json:"createTimeGT,omitempty"`
	CreateTimeGTE   *time.Time  `json:"createTimeGTE,omitempty"`
	CreateTimeLT    *time.Time  `json:"createTimeLT,omitempty"`
	CreateTimeLTE   *time.Time  `json:"createTimeLTE,omitempty"`

	// "update_time" field predicates.
	UpdateTime       *time.Time  `json:"updateTime,omitempty"`
	UpdateTimeNEQ    *time.Time  `json:"updateTimeNEQ,omitempty"`
	UpdateTimeIn     []time.Time `json:"updateTimeIn,omitempty"`
	UpdateTimeNotIn  []time.Time `json:"updateTimeNotIn,omitempty"`
	UpdateTimeGT     *time.Time  `json:"updateTimeGT,omitempty"`
	UpdateTimeGTE    *time.Time  `json:"updateTimeGTE,omitempty"`
	UpdateTimeLT     *time.Time  `json:"updateTimeLT,omitempty"`
	UpdateTimeLTE    *time.Time  `json:"updateTimeLTE,omitempty"`
	UpdateTimeIsNil  bool        `json:"updateTimeIsNil,omitempty"`
	UpdateTimeNotNil bool        `json:"updateTimeNotNil,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "duty" field predicates.
	Duty             *string  `json:"duty,omitempty"`
	DutyNEQ          *string  `json:"dutyNEQ,omitempty"`
	DutyIn           []string `json:"dutyIn,omitempty"`
	DutyNotIn        []string `json:"dutyNotIn,omitempty"`
	DutyGT           *string  `json:"dutyGT,omitempty"`
	DutyGTE          *string  `json:"dutyGTE,omitempty"`
	DutyLT           *string  `json:"dutyLT,omitempty"`
	DutyLTE          *string  `json:"dutyLTE,omitempty"`
	DutyContains     *string  `json:"dutyContains,omitempty"`
	DutyHasPrefix    *string  `json:"dutyHasPrefix,omitempty"`
	DutyHasSuffix    *string  `json:"dutyHasSuffix,omitempty"`
	DutyIsNil        bool     `json:"dutyIsNil,omitempty"`
	DutyNotNil       bool     `json:"dutyNotNil,omitempty"`
	DutyEqualFold    *string  `json:"dutyEqualFold,omitempty"`
	DutyContainsFold *string  `json:"dutyContainsFold,omitempty"`

	// "create_by" edge predicates.
	HasCreateBy     *bool             `json:"hasCreateBy,omitempty"`
	HasCreateByWith []*UserWhereInput `json:"hasCreateByWith,omitempty"`

	// "update_by" edge predicates.
	HasUpdateBy     *bool             `json:"hasUpdateBy,omitempty"`
	HasUpdateByWith []*UserWhereInput `json:"hasUpdateByWith,omitempty"`

	// "members" edge predicates.
	HasMembers     *bool                      `json:"hasMembers,omitempty"`
	HasMembersWith []*OrgUnitMemberWhereInput `json:"hasMembersWith,omitempty"`

	// "positions" edge predicates.
	HasPositions     *bool                        `json:"hasPositions,omitempty"`
	HasPositionsWith []*OrgUnitPositionWhereInput `json:"hasPositionsWith,omitempty"`

	// "supUnit" edge predicates.
	HasSupUnit     *bool                `json:"hasSupUnit,omitempty"`
	HasSupUnitWith []*OrgUnitWhereInput `json:"hasSupUnitWith,omitempty"`

	// "subUnits" edge predicates.
	HasSubUnits     *bool                `json:"hasSubUnits,omitempty"`
	HasSubUnitsWith []*OrgUnitWhereInput `json:"hasSubUnitsWith,omitempty"`

	// "belongToOrg" edge predicates.
	HasBelongToOrg     *bool                     `json:"hasBelongToOrg,omitempty"`
	HasBelongToOrgWith []*OrganizationWhereInput `json:"hasBelongToOrgWith,omitempty"`
}

// Filter applies the OrgUnitWhereInput filter on the OrgUnitQuery builder.
func (i *OrgUnitWhereInput) Filter(q *OrgUnitQuery) (*OrgUnitQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		return nil, err
	}
	return q.Where(p), nil
}

// P returns a predicate for filtering orgunits.
// An error is returned if the input is empty or invalid.
func (i *OrgUnitWhereInput) P() (predicate.OrgUnit, error) {
	var predicates []predicate.OrgUnit
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, orgunit.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.OrgUnit, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			or = append(or, p)
		}
		predicates = append(predicates, orgunit.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.OrgUnit, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			and = append(and, p)
		}
		predicates = append(predicates, orgunit.And(and...))
	}
	if i.ID != nil {
		predicates = append(predicates, orgunit.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, orgunit.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, orgunit.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, orgunit.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, orgunit.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, orgunit.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, orgunit.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, orgunit.IDLTE(*i.IDLTE))
	}
	if i.CreateByUser != nil {
		predicates = append(predicates, orgunit.CreateByUserEQ(*i.CreateByUser))
	}
	if i.CreateByUserNEQ != nil {
		predicates = append(predicates, orgunit.CreateByUserNEQ(*i.CreateByUserNEQ))
	}
	if len(i.CreateByUserIn) > 0 {
		predicates = append(predicates, orgunit.CreateByUserIn(i.CreateByUserIn...))
	}
	if len(i.CreateByUserNotIn) > 0 {
		predicates = append(predicates, orgunit.CreateByUserNotIn(i.CreateByUserNotIn...))
	}
	if i.CreateByUserIsNil {
		predicates = append(predicates, orgunit.CreateByUserIsNil())
	}
	if i.CreateByUserNotNil {
		predicates = append(predicates, orgunit.CreateByUserNotNil())
	}
	if i.UpdateByUser != nil {
		predicates = append(predicates, orgunit.UpdateByUserEQ(*i.UpdateByUser))
	}
	if i.UpdateByUserNEQ != nil {
		predicates = append(predicates, orgunit.UpdateByUserNEQ(*i.UpdateByUserNEQ))
	}
	if len(i.UpdateByUserIn) > 0 {
		predicates = append(predicates, orgunit.UpdateByUserIn(i.UpdateByUserIn...))
	}
	if len(i.UpdateByUserNotIn) > 0 {
		predicates = append(predicates, orgunit.UpdateByUserNotIn(i.UpdateByUserNotIn...))
	}
	if i.UpdateByUserIsNil {
		predicates = append(predicates, orgunit.UpdateByUserIsNil())
	}
	if i.UpdateByUserNotNil {
		predicates = append(predicates, orgunit.UpdateByUserNotNil())
	}
	if i.CreateTime != nil {
		predicates = append(predicates, orgunit.CreateTimeEQ(*i.CreateTime))
	}
	if i.CreateTimeNEQ != nil {
		predicates = append(predicates, orgunit.CreateTimeNEQ(*i.CreateTimeNEQ))
	}
	if len(i.CreateTimeIn) > 0 {
		predicates = append(predicates, orgunit.CreateTimeIn(i.CreateTimeIn...))
	}
	if len(i.CreateTimeNotIn) > 0 {
		predicates = append(predicates, orgunit.CreateTimeNotIn(i.CreateTimeNotIn...))
	}
	if i.CreateTimeGT != nil {
		predicates = append(predicates, orgunit.CreateTimeGT(*i.CreateTimeGT))
	}
	if i.CreateTimeGTE != nil {
		predicates = append(predicates, orgunit.CreateTimeGTE(*i.CreateTimeGTE))
	}
	if i.CreateTimeLT != nil {
		predicates = append(predicates, orgunit.CreateTimeLT(*i.CreateTimeLT))
	}
	if i.CreateTimeLTE != nil {
		predicates = append(predicates, orgunit.CreateTimeLTE(*i.CreateTimeLTE))
	}
	if i.UpdateTime != nil {
		predicates = append(predicates, orgunit.UpdateTimeEQ(*i.UpdateTime))
	}
	if i.UpdateTimeNEQ != nil {
		predicates = append(predicates, orgunit.UpdateTimeNEQ(*i.UpdateTimeNEQ))
	}
	if len(i.UpdateTimeIn) > 0 {
		predicates = append(predicates, orgunit.UpdateTimeIn(i.UpdateTimeIn...))
	}
	if len(i.UpdateTimeNotIn) > 0 {
		predicates = append(predicates, orgunit.UpdateTimeNotIn(i.UpdateTimeNotIn...))
	}
	if i.UpdateTimeGT != nil {
		predicates = append(predicates, orgunit.UpdateTimeGT(*i.UpdateTimeGT))
	}
	if i.UpdateTimeGTE != nil {
		predicates = append(predicates, orgunit.UpdateTimeGTE(*i.UpdateTimeGTE))
	}
	if i.UpdateTimeLT != nil {
		predicates = append(predicates, orgunit.UpdateTimeLT(*i.UpdateTimeLT))
	}
	if i.UpdateTimeLTE != nil {
		predicates = append(predicates, orgunit.UpdateTimeLTE(*i.UpdateTimeLTE))
	}
	if i.UpdateTimeIsNil {
		predicates = append(predicates, orgunit.UpdateTimeIsNil())
	}
	if i.UpdateTimeNotNil {
		predicates = append(predicates, orgunit.UpdateTimeNotNil())
	}
	if i.Name != nil {
		predicates = append(predicates, orgunit.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, orgunit.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, orgunit.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, orgunit.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, orgunit.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, orgunit.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, orgunit.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, orgunit.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, orgunit.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, orgunit.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, orgunit.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, orgunit.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, orgunit.NameContainsFold(*i.NameContainsFold))
	}
	if i.Duty != nil {
		predicates = append(predicates, orgunit.DutyEQ(*i.Duty))
	}
	if i.DutyNEQ != nil {
		predicates = append(predicates, orgunit.DutyNEQ(*i.DutyNEQ))
	}
	if len(i.DutyIn) > 0 {
		predicates = append(predicates, orgunit.DutyIn(i.DutyIn...))
	}
	if len(i.DutyNotIn) > 0 {
		predicates = append(predicates, orgunit.DutyNotIn(i.DutyNotIn...))
	}
	if i.DutyGT != nil {
		predicates = append(predicates, orgunit.DutyGT(*i.DutyGT))
	}
	if i.DutyGTE != nil {
		predicates = append(predicates, orgunit.DutyGTE(*i.DutyGTE))
	}
	if i.DutyLT != nil {
		predicates = append(predicates, orgunit.DutyLT(*i.DutyLT))
	}
	if i.DutyLTE != nil {
		predicates = append(predicates, orgunit.DutyLTE(*i.DutyLTE))
	}
	if i.DutyContains != nil {
		predicates = append(predicates, orgunit.DutyContains(*i.DutyContains))
	}
	if i.DutyHasPrefix != nil {
		predicates = append(predicates, orgunit.DutyHasPrefix(*i.DutyHasPrefix))
	}
	if i.DutyHasSuffix != nil {
		predicates = append(predicates, orgunit.DutyHasSuffix(*i.DutyHasSuffix))
	}
	if i.DutyIsNil {
		predicates = append(predicates, orgunit.DutyIsNil())
	}
	if i.DutyNotNil {
		predicates = append(predicates, orgunit.DutyNotNil())
	}
	if i.DutyEqualFold != nil {
		predicates = append(predicates, orgunit.DutyEqualFold(*i.DutyEqualFold))
	}
	if i.DutyContainsFold != nil {
		predicates = append(predicates, orgunit.DutyContainsFold(*i.DutyContainsFold))
	}

	if i.HasCreateBy != nil {
		p := orgunit.HasCreateBy()
		if !*i.HasCreateBy {
			p = orgunit.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCreateByWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasCreateByWith))
		for _, w := range i.HasCreateByWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, orgunit.HasCreateByWith(with...))
	}
	if i.HasUpdateBy != nil {
		p := orgunit.HasUpdateBy()
		if !*i.HasUpdateBy {
			p = orgunit.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasUpdateByWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasUpdateByWith))
		for _, w := range i.HasUpdateByWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, orgunit.HasUpdateByWith(with...))
	}
	if i.HasMembers != nil {
		p := orgunit.HasMembers()
		if !*i.HasMembers {
			p = orgunit.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasMembersWith) > 0 {
		with := make([]predicate.OrgUnitMember, 0, len(i.HasMembersWith))
		for _, w := range i.HasMembersWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, orgunit.HasMembersWith(with...))
	}
	if i.HasPositions != nil {
		p := orgunit.HasPositions()
		if !*i.HasPositions {
			p = orgunit.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasPositionsWith) > 0 {
		with := make([]predicate.OrgUnitPosition, 0, len(i.HasPositionsWith))
		for _, w := range i.HasPositionsWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, orgunit.HasPositionsWith(with...))
	}
	if i.HasSupUnit != nil {
		p := orgunit.HasSupUnit()
		if !*i.HasSupUnit {
			p = orgunit.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasSupUnitWith) > 0 {
		with := make([]predicate.OrgUnit, 0, len(i.HasSupUnitWith))
		for _, w := range i.HasSupUnitWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, orgunit.HasSupUnitWith(with...))
	}
	if i.HasSubUnits != nil {
		p := orgunit.HasSubUnits()
		if !*i.HasSubUnits {
			p = orgunit.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasSubUnitsWith) > 0 {
		with := make([]predicate.OrgUnit, 0, len(i.HasSubUnitsWith))
		for _, w := range i.HasSubUnitsWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, orgunit.HasSubUnitsWith(with...))
	}
	if i.HasBelongToOrg != nil {
		p := orgunit.HasBelongToOrg()
		if !*i.HasBelongToOrg {
			p = orgunit.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasBelongToOrgWith) > 0 {
		with := make([]predicate.Organization, 0, len(i.HasBelongToOrgWith))
		for _, w := range i.HasBelongToOrgWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, orgunit.HasBelongToOrgWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, fmt.Errorf("wing/models/ent: empty predicate OrgUnitWhereInput")
	case 1:
		return predicates[0], nil
	default:
		return orgunit.And(predicates...), nil
	}
}

// OrgUnitMemberWhereInput represents a where input for filtering OrgUnitMember queries.
type OrgUnitMemberWhereInput struct {
	Not *OrgUnitMemberWhereInput   `json:"not,omitempty"`
	Or  []*OrgUnitMemberWhereInput `json:"or,omitempty"`
	And []*OrgUnitMemberWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "create_by_user" field predicates.
	CreateByUser       *int  `json:"createByUser,omitempty"`
	CreateByUserNEQ    *int  `json:"createByUserNEQ,omitempty"`
	CreateByUserIn     []int `json:"createByUserIn,omitempty"`
	CreateByUserNotIn  []int `json:"createByUserNotIn,omitempty"`
	CreateByUserIsNil  bool  `json:"createByUserIsNil,omitempty"`
	CreateByUserNotNil bool  `json:"createByUserNotNil,omitempty"`

	// "update_by_user" field predicates.
	UpdateByUser       *int  `json:"updateByUser,omitempty"`
	UpdateByUserNEQ    *int  `json:"updateByUserNEQ,omitempty"`
	UpdateByUserIn     []int `json:"updateByUserIn,omitempty"`
	UpdateByUserNotIn  []int `json:"updateByUserNotIn,omitempty"`
	UpdateByUserIsNil  bool  `json:"updateByUserIsNil,omitempty"`
	UpdateByUserNotNil bool  `json:"updateByUserNotNil,omitempty"`

	// "create_time" field predicates.
	CreateTime      *time.Time  `json:"createTime,omitempty"`
	CreateTimeNEQ   *time.Time  `json:"createTimeNEQ,omitempty"`
	CreateTimeIn    []time.Time `json:"createTimeIn,omitempty"`
	CreateTimeNotIn []time.Time `json:"createTimeNotIn,omitempty"`
	CreateTimeGT    *time.Time  `json:"createTimeGT,omitempty"`
	CreateTimeGTE   *time.Time  `json:"createTimeGTE,omitempty"`
	CreateTimeLT    *time.Time  `json:"createTimeLT,omitempty"`
	CreateTimeLTE   *time.Time  `json:"createTimeLTE,omitempty"`

	// "update_time" field predicates.
	UpdateTime       *time.Time  `json:"updateTime,omitempty"`
	UpdateTimeNEQ    *time.Time  `json:"updateTimeNEQ,omitempty"`
	UpdateTimeIn     []time.Time `json:"updateTimeIn,omitempty"`
	UpdateTimeNotIn  []time.Time `json:"updateTimeNotIn,omitempty"`
	UpdateTimeGT     *time.Time  `json:"updateTimeGT,omitempty"`
	UpdateTimeGTE    *time.Time  `json:"updateTimeGTE,omitempty"`
	UpdateTimeLT     *time.Time  `json:"updateTimeLT,omitempty"`
	UpdateTimeLTE    *time.Time  `json:"updateTimeLTE,omitempty"`
	UpdateTimeIsNil  bool        `json:"updateTimeIsNil,omitempty"`
	UpdateTimeNotNil bool        `json:"updateTimeNotNil,omitempty"`

	// "is_additional" field predicates.
	IsAdditional    *bool `json:"isAdditional,omitempty"`
	IsAdditionalNEQ *bool `json:"isAdditionalNEQ,omitempty"`

	// "user_id" field predicates.
	UserID      *int  `json:"userID,omitempty"`
	UserIDNEQ   *int  `json:"userIDNEQ,omitempty"`
	UserIDIn    []int `json:"userIDIn,omitempty"`
	UserIDNotIn []int `json:"userIDNotIn,omitempty"`

	// "org_unit_id" field predicates.
	OrgUnitID      *int  `json:"orgUnitID,omitempty"`
	OrgUnitIDNEQ   *int  `json:"orgUnitIDNEQ,omitempty"`
	OrgUnitIDIn    []int `json:"orgUnitIDIn,omitempty"`
	OrgUnitIDNotIn []int `json:"orgUnitIDNotIn,omitempty"`

	// "org_unit_position_id" field predicates.
	OrgUnitPositionID      *int  `json:"orgUnitPositionID,omitempty"`
	OrgUnitPositionIDNEQ   *int  `json:"orgUnitPositionIDNEQ,omitempty"`
	OrgUnitPositionIDIn    []int `json:"orgUnitPositionIDIn,omitempty"`
	OrgUnitPositionIDNotIn []int `json:"orgUnitPositionIDNotIn,omitempty"`

	// "create_by" edge predicates.
	HasCreateBy     *bool             `json:"hasCreateBy,omitempty"`
	HasCreateByWith []*UserWhereInput `json:"hasCreateByWith,omitempty"`

	// "update_by" edge predicates.
	HasUpdateBy     *bool             `json:"hasUpdateBy,omitempty"`
	HasUpdateByWith []*UserWhereInput `json:"hasUpdateByWith,omitempty"`

	// "user" edge predicates.
	HasUser     *bool             `json:"hasUser,omitempty"`
	HasUserWith []*UserWhereInput `json:"hasUserWith,omitempty"`

	// "position" edge predicates.
	HasPosition     *bool                        `json:"hasPosition,omitempty"`
	HasPositionWith []*OrgUnitPositionWhereInput `json:"hasPositionWith,omitempty"`

	// "belongToOrgUnit" edge predicates.
	HasBelongToOrgUnit     *bool                `json:"hasBelongToOrgUnit,omitempty"`
	HasBelongToOrgUnitWith []*OrgUnitWhereInput `json:"hasBelongToOrgUnitWith,omitempty"`
}

// Filter applies the OrgUnitMemberWhereInput filter on the OrgUnitMemberQuery builder.
func (i *OrgUnitMemberWhereInput) Filter(q *OrgUnitMemberQuery) (*OrgUnitMemberQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		return nil, err
	}
	return q.Where(p), nil
}

// P returns a predicate for filtering orgunitmembers.
// An error is returned if the input is empty or invalid.
func (i *OrgUnitMemberWhereInput) P() (predicate.OrgUnitMember, error) {
	var predicates []predicate.OrgUnitMember
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, orgunitmember.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.OrgUnitMember, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			or = append(or, p)
		}
		predicates = append(predicates, orgunitmember.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.OrgUnitMember, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			and = append(and, p)
		}
		predicates = append(predicates, orgunitmember.And(and...))
	}
	if i.ID != nil {
		predicates = append(predicates, orgunitmember.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, orgunitmember.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, orgunitmember.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, orgunitmember.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, orgunitmember.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, orgunitmember.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, orgunitmember.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, orgunitmember.IDLTE(*i.IDLTE))
	}
	if i.CreateByUser != nil {
		predicates = append(predicates, orgunitmember.CreateByUserEQ(*i.CreateByUser))
	}
	if i.CreateByUserNEQ != nil {
		predicates = append(predicates, orgunitmember.CreateByUserNEQ(*i.CreateByUserNEQ))
	}
	if len(i.CreateByUserIn) > 0 {
		predicates = append(predicates, orgunitmember.CreateByUserIn(i.CreateByUserIn...))
	}
	if len(i.CreateByUserNotIn) > 0 {
		predicates = append(predicates, orgunitmember.CreateByUserNotIn(i.CreateByUserNotIn...))
	}
	if i.CreateByUserIsNil {
		predicates = append(predicates, orgunitmember.CreateByUserIsNil())
	}
	if i.CreateByUserNotNil {
		predicates = append(predicates, orgunitmember.CreateByUserNotNil())
	}
	if i.UpdateByUser != nil {
		predicates = append(predicates, orgunitmember.UpdateByUserEQ(*i.UpdateByUser))
	}
	if i.UpdateByUserNEQ != nil {
		predicates = append(predicates, orgunitmember.UpdateByUserNEQ(*i.UpdateByUserNEQ))
	}
	if len(i.UpdateByUserIn) > 0 {
		predicates = append(predicates, orgunitmember.UpdateByUserIn(i.UpdateByUserIn...))
	}
	if len(i.UpdateByUserNotIn) > 0 {
		predicates = append(predicates, orgunitmember.UpdateByUserNotIn(i.UpdateByUserNotIn...))
	}
	if i.UpdateByUserIsNil {
		predicates = append(predicates, orgunitmember.UpdateByUserIsNil())
	}
	if i.UpdateByUserNotNil {
		predicates = append(predicates, orgunitmember.UpdateByUserNotNil())
	}
	if i.CreateTime != nil {
		predicates = append(predicates, orgunitmember.CreateTimeEQ(*i.CreateTime))
	}
	if i.CreateTimeNEQ != nil {
		predicates = append(predicates, orgunitmember.CreateTimeNEQ(*i.CreateTimeNEQ))
	}
	if len(i.CreateTimeIn) > 0 {
		predicates = append(predicates, orgunitmember.CreateTimeIn(i.CreateTimeIn...))
	}
	if len(i.CreateTimeNotIn) > 0 {
		predicates = append(predicates, orgunitmember.CreateTimeNotIn(i.CreateTimeNotIn...))
	}
	if i.CreateTimeGT != nil {
		predicates = append(predicates, orgunitmember.CreateTimeGT(*i.CreateTimeGT))
	}
	if i.CreateTimeGTE != nil {
		predicates = append(predicates, orgunitmember.CreateTimeGTE(*i.CreateTimeGTE))
	}
	if i.CreateTimeLT != nil {
		predicates = append(predicates, orgunitmember.CreateTimeLT(*i.CreateTimeLT))
	}
	if i.CreateTimeLTE != nil {
		predicates = append(predicates, orgunitmember.CreateTimeLTE(*i.CreateTimeLTE))
	}
	if i.UpdateTime != nil {
		predicates = append(predicates, orgunitmember.UpdateTimeEQ(*i.UpdateTime))
	}
	if i.UpdateTimeNEQ != nil {
		predicates = append(predicates, orgunitmember.UpdateTimeNEQ(*i.UpdateTimeNEQ))
	}
	if len(i.UpdateTimeIn) > 0 {
		predicates = append(predicates, orgunitmember.UpdateTimeIn(i.UpdateTimeIn...))
	}
	if len(i.UpdateTimeNotIn) > 0 {
		predicates = append(predicates, orgunitmember.UpdateTimeNotIn(i.UpdateTimeNotIn...))
	}
	if i.UpdateTimeGT != nil {
		predicates = append(predicates, orgunitmember.UpdateTimeGT(*i.UpdateTimeGT))
	}
	if i.UpdateTimeGTE != nil {
		predicates = append(predicates, orgunitmember.UpdateTimeGTE(*i.UpdateTimeGTE))
	}
	if i.UpdateTimeLT != nil {
		predicates = append(predicates, orgunitmember.UpdateTimeLT(*i.UpdateTimeLT))
	}
	if i.UpdateTimeLTE != nil {
		predicates = append(predicates, orgunitmember.UpdateTimeLTE(*i.UpdateTimeLTE))
	}
	if i.UpdateTimeIsNil {
		predicates = append(predicates, orgunitmember.UpdateTimeIsNil())
	}
	if i.UpdateTimeNotNil {
		predicates = append(predicates, orgunitmember.UpdateTimeNotNil())
	}
	if i.IsAdditional != nil {
		predicates = append(predicates, orgunitmember.IsAdditionalEQ(*i.IsAdditional))
	}
	if i.IsAdditionalNEQ != nil {
		predicates = append(predicates, orgunitmember.IsAdditionalNEQ(*i.IsAdditionalNEQ))
	}
	if i.UserID != nil {
		predicates = append(predicates, orgunitmember.UserIDEQ(*i.UserID))
	}
	if i.UserIDNEQ != nil {
		predicates = append(predicates, orgunitmember.UserIDNEQ(*i.UserIDNEQ))
	}
	if len(i.UserIDIn) > 0 {
		predicates = append(predicates, orgunitmember.UserIDIn(i.UserIDIn...))
	}
	if len(i.UserIDNotIn) > 0 {
		predicates = append(predicates, orgunitmember.UserIDNotIn(i.UserIDNotIn...))
	}
	if i.OrgUnitID != nil {
		predicates = append(predicates, orgunitmember.OrgUnitIDEQ(*i.OrgUnitID))
	}
	if i.OrgUnitIDNEQ != nil {
		predicates = append(predicates, orgunitmember.OrgUnitIDNEQ(*i.OrgUnitIDNEQ))
	}
	if len(i.OrgUnitIDIn) > 0 {
		predicates = append(predicates, orgunitmember.OrgUnitIDIn(i.OrgUnitIDIn...))
	}
	if len(i.OrgUnitIDNotIn) > 0 {
		predicates = append(predicates, orgunitmember.OrgUnitIDNotIn(i.OrgUnitIDNotIn...))
	}
	if i.OrgUnitPositionID != nil {
		predicates = append(predicates, orgunitmember.OrgUnitPositionIDEQ(*i.OrgUnitPositionID))
	}
	if i.OrgUnitPositionIDNEQ != nil {
		predicates = append(predicates, orgunitmember.OrgUnitPositionIDNEQ(*i.OrgUnitPositionIDNEQ))
	}
	if len(i.OrgUnitPositionIDIn) > 0 {
		predicates = append(predicates, orgunitmember.OrgUnitPositionIDIn(i.OrgUnitPositionIDIn...))
	}
	if len(i.OrgUnitPositionIDNotIn) > 0 {
		predicates = append(predicates, orgunitmember.OrgUnitPositionIDNotIn(i.OrgUnitPositionIDNotIn...))
	}

	if i.HasCreateBy != nil {
		p := orgunitmember.HasCreateBy()
		if !*i.HasCreateBy {
			p = orgunitmember.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCreateByWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasCreateByWith))
		for _, w := range i.HasCreateByWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, orgunitmember.HasCreateByWith(with...))
	}
	if i.HasUpdateBy != nil {
		p := orgunitmember.HasUpdateBy()
		if !*i.HasUpdateBy {
			p = orgunitmember.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasUpdateByWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasUpdateByWith))
		for _, w := range i.HasUpdateByWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, orgunitmember.HasUpdateByWith(with...))
	}
	if i.HasUser != nil {
		p := orgunitmember.HasUser()
		if !*i.HasUser {
			p = orgunitmember.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasUserWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasUserWith))
		for _, w := range i.HasUserWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, orgunitmember.HasUserWith(with...))
	}
	if i.HasPosition != nil {
		p := orgunitmember.HasPosition()
		if !*i.HasPosition {
			p = orgunitmember.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasPositionWith) > 0 {
		with := make([]predicate.OrgUnitPosition, 0, len(i.HasPositionWith))
		for _, w := range i.HasPositionWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, orgunitmember.HasPositionWith(with...))
	}
	if i.HasBelongToOrgUnit != nil {
		p := orgunitmember.HasBelongToOrgUnit()
		if !*i.HasBelongToOrgUnit {
			p = orgunitmember.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasBelongToOrgUnitWith) > 0 {
		with := make([]predicate.OrgUnit, 0, len(i.HasBelongToOrgUnitWith))
		for _, w := range i.HasBelongToOrgUnitWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, orgunitmember.HasBelongToOrgUnitWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, fmt.Errorf("wing/models/ent: empty predicate OrgUnitMemberWhereInput")
	case 1:
		return predicates[0], nil
	default:
		return orgunitmember.And(predicates...), nil
	}
}

// OrgUnitPositionWhereInput represents a where input for filtering OrgUnitPosition queries.
type OrgUnitPositionWhereInput struct {
	Not *OrgUnitPositionWhereInput   `json:"not,omitempty"`
	Or  []*OrgUnitPositionWhereInput `json:"or,omitempty"`
	And []*OrgUnitPositionWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "create_by_user" field predicates.
	CreateByUser       *int  `json:"createByUser,omitempty"`
	CreateByUserNEQ    *int  `json:"createByUserNEQ,omitempty"`
	CreateByUserIn     []int `json:"createByUserIn,omitempty"`
	CreateByUserNotIn  []int `json:"createByUserNotIn,omitempty"`
	CreateByUserIsNil  bool  `json:"createByUserIsNil,omitempty"`
	CreateByUserNotNil bool  `json:"createByUserNotNil,omitempty"`

	// "update_by_user" field predicates.
	UpdateByUser       *int  `json:"updateByUser,omitempty"`
	UpdateByUserNEQ    *int  `json:"updateByUserNEQ,omitempty"`
	UpdateByUserIn     []int `json:"updateByUserIn,omitempty"`
	UpdateByUserNotIn  []int `json:"updateByUserNotIn,omitempty"`
	UpdateByUserIsNil  bool  `json:"updateByUserIsNil,omitempty"`
	UpdateByUserNotNil bool  `json:"updateByUserNotNil,omitempty"`

	// "create_time" field predicates.
	CreateTime      *time.Time  `json:"createTime,omitempty"`
	CreateTimeNEQ   *time.Time  `json:"createTimeNEQ,omitempty"`
	CreateTimeIn    []time.Time `json:"createTimeIn,omitempty"`
	CreateTimeNotIn []time.Time `json:"createTimeNotIn,omitempty"`
	CreateTimeGT    *time.Time  `json:"createTimeGT,omitempty"`
	CreateTimeGTE   *time.Time  `json:"createTimeGTE,omitempty"`
	CreateTimeLT    *time.Time  `json:"createTimeLT,omitempty"`
	CreateTimeLTE   *time.Time  `json:"createTimeLTE,omitempty"`

	// "update_time" field predicates.
	UpdateTime       *time.Time  `json:"updateTime,omitempty"`
	UpdateTimeNEQ    *time.Time  `json:"updateTimeNEQ,omitempty"`
	UpdateTimeIn     []time.Time `json:"updateTimeIn,omitempty"`
	UpdateTimeNotIn  []time.Time `json:"updateTimeNotIn,omitempty"`
	UpdateTimeGT     *time.Time  `json:"updateTimeGT,omitempty"`
	UpdateTimeGTE    *time.Time  `json:"updateTimeGTE,omitempty"`
	UpdateTimeLT     *time.Time  `json:"updateTimeLT,omitempty"`
	UpdateTimeLTE    *time.Time  `json:"updateTimeLTE,omitempty"`
	UpdateTimeIsNil  bool        `json:"updateTimeIsNil,omitempty"`
	UpdateTimeNotNil bool        `json:"updateTimeNotNil,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "duty" field predicates.
	Duty             *string  `json:"duty,omitempty"`
	DutyNEQ          *string  `json:"dutyNEQ,omitempty"`
	DutyIn           []string `json:"dutyIn,omitempty"`
	DutyNotIn        []string `json:"dutyNotIn,omitempty"`
	DutyGT           *string  `json:"dutyGT,omitempty"`
	DutyGTE          *string  `json:"dutyGTE,omitempty"`
	DutyLT           *string  `json:"dutyLT,omitempty"`
	DutyLTE          *string  `json:"dutyLTE,omitempty"`
	DutyContains     *string  `json:"dutyContains,omitempty"`
	DutyHasPrefix    *string  `json:"dutyHasPrefix,omitempty"`
	DutyHasSuffix    *string  `json:"dutyHasSuffix,omitempty"`
	DutyIsNil        bool     `json:"dutyIsNil,omitempty"`
	DutyNotNil       bool     `json:"dutyNotNil,omitempty"`
	DutyEqualFold    *string  `json:"dutyEqualFold,omitempty"`
	DutyContainsFold *string  `json:"dutyContainsFold,omitempty"`

	// "level" field predicates.
	Level      *int  `json:"level,omitempty"`
	LevelNEQ   *int  `json:"levelNEQ,omitempty"`
	LevelIn    []int `json:"levelIn,omitempty"`
	LevelNotIn []int `json:"levelNotIn,omitempty"`
	LevelGT    *int  `json:"levelGT,omitempty"`
	LevelGTE   *int  `json:"levelGTE,omitempty"`
	LevelLT    *int  `json:"levelLT,omitempty"`
	LevelLTE   *int  `json:"levelLTE,omitempty"`

	// "org_unit_id" field predicates.
	OrgUnitID      *int  `json:"orgUnitID,omitempty"`
	OrgUnitIDNEQ   *int  `json:"orgUnitIDNEQ,omitempty"`
	OrgUnitIDIn    []int `json:"orgUnitIDIn,omitempty"`
	OrgUnitIDNotIn []int `json:"orgUnitIDNotIn,omitempty"`

	// "create_by" edge predicates.
	HasCreateBy     *bool             `json:"hasCreateBy,omitempty"`
	HasCreateByWith []*UserWhereInput `json:"hasCreateByWith,omitempty"`

	// "update_by" edge predicates.
	HasUpdateBy     *bool             `json:"hasUpdateBy,omitempty"`
	HasUpdateByWith []*UserWhereInput `json:"hasUpdateByWith,omitempty"`

	// "belongToOrgUnitMembers" edge predicates.
	HasBelongToOrgUnitMembers     *bool                      `json:"hasBelongToOrgUnitMembers,omitempty"`
	HasBelongToOrgUnitMembersWith []*OrgUnitMemberWhereInput `json:"hasBelongToOrgUnitMembersWith,omitempty"`

	// "belongToOrgUnit" edge predicates.
	HasBelongToOrgUnit     *bool                `json:"hasBelongToOrgUnit,omitempty"`
	HasBelongToOrgUnitWith []*OrgUnitWhereInput `json:"hasBelongToOrgUnitWith,omitempty"`
}

// Filter applies the OrgUnitPositionWhereInput filter on the OrgUnitPositionQuery builder.
func (i *OrgUnitPositionWhereInput) Filter(q *OrgUnitPositionQuery) (*OrgUnitPositionQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		return nil, err
	}
	return q.Where(p), nil
}

// P returns a predicate for filtering orgunitpositions.
// An error is returned if the input is empty or invalid.
func (i *OrgUnitPositionWhereInput) P() (predicate.OrgUnitPosition, error) {
	var predicates []predicate.OrgUnitPosition
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, orgunitposition.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.OrgUnitPosition, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			or = append(or, p)
		}
		predicates = append(predicates, orgunitposition.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.OrgUnitPosition, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			and = append(and, p)
		}
		predicates = append(predicates, orgunitposition.And(and...))
	}
	if i.ID != nil {
		predicates = append(predicates, orgunitposition.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, orgunitposition.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, orgunitposition.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, orgunitposition.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, orgunitposition.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, orgunitposition.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, orgunitposition.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, orgunitposition.IDLTE(*i.IDLTE))
	}
	if i.CreateByUser != nil {
		predicates = append(predicates, orgunitposition.CreateByUserEQ(*i.CreateByUser))
	}
	if i.CreateByUserNEQ != nil {
		predicates = append(predicates, orgunitposition.CreateByUserNEQ(*i.CreateByUserNEQ))
	}
	if len(i.CreateByUserIn) > 0 {
		predicates = append(predicates, orgunitposition.CreateByUserIn(i.CreateByUserIn...))
	}
	if len(i.CreateByUserNotIn) > 0 {
		predicates = append(predicates, orgunitposition.CreateByUserNotIn(i.CreateByUserNotIn...))
	}
	if i.CreateByUserIsNil {
		predicates = append(predicates, orgunitposition.CreateByUserIsNil())
	}
	if i.CreateByUserNotNil {
		predicates = append(predicates, orgunitposition.CreateByUserNotNil())
	}
	if i.UpdateByUser != nil {
		predicates = append(predicates, orgunitposition.UpdateByUserEQ(*i.UpdateByUser))
	}
	if i.UpdateByUserNEQ != nil {
		predicates = append(predicates, orgunitposition.UpdateByUserNEQ(*i.UpdateByUserNEQ))
	}
	if len(i.UpdateByUserIn) > 0 {
		predicates = append(predicates, orgunitposition.UpdateByUserIn(i.UpdateByUserIn...))
	}
	if len(i.UpdateByUserNotIn) > 0 {
		predicates = append(predicates, orgunitposition.UpdateByUserNotIn(i.UpdateByUserNotIn...))
	}
	if i.UpdateByUserIsNil {
		predicates = append(predicates, orgunitposition.UpdateByUserIsNil())
	}
	if i.UpdateByUserNotNil {
		predicates = append(predicates, orgunitposition.UpdateByUserNotNil())
	}
	if i.CreateTime != nil {
		predicates = append(predicates, orgunitposition.CreateTimeEQ(*i.CreateTime))
	}
	if i.CreateTimeNEQ != nil {
		predicates = append(predicates, orgunitposition.CreateTimeNEQ(*i.CreateTimeNEQ))
	}
	if len(i.CreateTimeIn) > 0 {
		predicates = append(predicates, orgunitposition.CreateTimeIn(i.CreateTimeIn...))
	}
	if len(i.CreateTimeNotIn) > 0 {
		predicates = append(predicates, orgunitposition.CreateTimeNotIn(i.CreateTimeNotIn...))
	}
	if i.CreateTimeGT != nil {
		predicates = append(predicates, orgunitposition.CreateTimeGT(*i.CreateTimeGT))
	}
	if i.CreateTimeGTE != nil {
		predicates = append(predicates, orgunitposition.CreateTimeGTE(*i.CreateTimeGTE))
	}
	if i.CreateTimeLT != nil {
		predicates = append(predicates, orgunitposition.CreateTimeLT(*i.CreateTimeLT))
	}
	if i.CreateTimeLTE != nil {
		predicates = append(predicates, orgunitposition.CreateTimeLTE(*i.CreateTimeLTE))
	}
	if i.UpdateTime != nil {
		predicates = append(predicates, orgunitposition.UpdateTimeEQ(*i.UpdateTime))
	}
	if i.UpdateTimeNEQ != nil {
		predicates = append(predicates, orgunitposition.UpdateTimeNEQ(*i.UpdateTimeNEQ))
	}
	if len(i.UpdateTimeIn) > 0 {
		predicates = append(predicates, orgunitposition.UpdateTimeIn(i.UpdateTimeIn...))
	}
	if len(i.UpdateTimeNotIn) > 0 {
		predicates = append(predicates, orgunitposition.UpdateTimeNotIn(i.UpdateTimeNotIn...))
	}
	if i.UpdateTimeGT != nil {
		predicates = append(predicates, orgunitposition.UpdateTimeGT(*i.UpdateTimeGT))
	}
	if i.UpdateTimeGTE != nil {
		predicates = append(predicates, orgunitposition.UpdateTimeGTE(*i.UpdateTimeGTE))
	}
	if i.UpdateTimeLT != nil {
		predicates = append(predicates, orgunitposition.UpdateTimeLT(*i.UpdateTimeLT))
	}
	if i.UpdateTimeLTE != nil {
		predicates = append(predicates, orgunitposition.UpdateTimeLTE(*i.UpdateTimeLTE))
	}
	if i.UpdateTimeIsNil {
		predicates = append(predicates, orgunitposition.UpdateTimeIsNil())
	}
	if i.UpdateTimeNotNil {
		predicates = append(predicates, orgunitposition.UpdateTimeNotNil())
	}
	if i.Name != nil {
		predicates = append(predicates, orgunitposition.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, orgunitposition.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, orgunitposition.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, orgunitposition.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, orgunitposition.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, orgunitposition.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, orgunitposition.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, orgunitposition.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, orgunitposition.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, orgunitposition.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, orgunitposition.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, orgunitposition.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, orgunitposition.NameContainsFold(*i.NameContainsFold))
	}
	if i.Duty != nil {
		predicates = append(predicates, orgunitposition.DutyEQ(*i.Duty))
	}
	if i.DutyNEQ != nil {
		predicates = append(predicates, orgunitposition.DutyNEQ(*i.DutyNEQ))
	}
	if len(i.DutyIn) > 0 {
		predicates = append(predicates, orgunitposition.DutyIn(i.DutyIn...))
	}
	if len(i.DutyNotIn) > 0 {
		predicates = append(predicates, orgunitposition.DutyNotIn(i.DutyNotIn...))
	}
	if i.DutyGT != nil {
		predicates = append(predicates, orgunitposition.DutyGT(*i.DutyGT))
	}
	if i.DutyGTE != nil {
		predicates = append(predicates, orgunitposition.DutyGTE(*i.DutyGTE))
	}
	if i.DutyLT != nil {
		predicates = append(predicates, orgunitposition.DutyLT(*i.DutyLT))
	}
	if i.DutyLTE != nil {
		predicates = append(predicates, orgunitposition.DutyLTE(*i.DutyLTE))
	}
	if i.DutyContains != nil {
		predicates = append(predicates, orgunitposition.DutyContains(*i.DutyContains))
	}
	if i.DutyHasPrefix != nil {
		predicates = append(predicates, orgunitposition.DutyHasPrefix(*i.DutyHasPrefix))
	}
	if i.DutyHasSuffix != nil {
		predicates = append(predicates, orgunitposition.DutyHasSuffix(*i.DutyHasSuffix))
	}
	if i.DutyIsNil {
		predicates = append(predicates, orgunitposition.DutyIsNil())
	}
	if i.DutyNotNil {
		predicates = append(predicates, orgunitposition.DutyNotNil())
	}
	if i.DutyEqualFold != nil {
		predicates = append(predicates, orgunitposition.DutyEqualFold(*i.DutyEqualFold))
	}
	if i.DutyContainsFold != nil {
		predicates = append(predicates, orgunitposition.DutyContainsFold(*i.DutyContainsFold))
	}
	if i.Level != nil {
		predicates = append(predicates, orgunitposition.LevelEQ(*i.Level))
	}
	if i.LevelNEQ != nil {
		predicates = append(predicates, orgunitposition.LevelNEQ(*i.LevelNEQ))
	}
	if len(i.LevelIn) > 0 {
		predicates = append(predicates, orgunitposition.LevelIn(i.LevelIn...))
	}
	if len(i.LevelNotIn) > 0 {
		predicates = append(predicates, orgunitposition.LevelNotIn(i.LevelNotIn...))
	}
	if i.LevelGT != nil {
		predicates = append(predicates, orgunitposition.LevelGT(*i.LevelGT))
	}
	if i.LevelGTE != nil {
		predicates = append(predicates, orgunitposition.LevelGTE(*i.LevelGTE))
	}
	if i.LevelLT != nil {
		predicates = append(predicates, orgunitposition.LevelLT(*i.LevelLT))
	}
	if i.LevelLTE != nil {
		predicates = append(predicates, orgunitposition.LevelLTE(*i.LevelLTE))
	}
	if i.OrgUnitID != nil {
		predicates = append(predicates, orgunitposition.OrgUnitIDEQ(*i.OrgUnitID))
	}
	if i.OrgUnitIDNEQ != nil {
		predicates = append(predicates, orgunitposition.OrgUnitIDNEQ(*i.OrgUnitIDNEQ))
	}
	if len(i.OrgUnitIDIn) > 0 {
		predicates = append(predicates, orgunitposition.OrgUnitIDIn(i.OrgUnitIDIn...))
	}
	if len(i.OrgUnitIDNotIn) > 0 {
		predicates = append(predicates, orgunitposition.OrgUnitIDNotIn(i.OrgUnitIDNotIn...))
	}

	if i.HasCreateBy != nil {
		p := orgunitposition.HasCreateBy()
		if !*i.HasCreateBy {
			p = orgunitposition.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCreateByWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasCreateByWith))
		for _, w := range i.HasCreateByWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, orgunitposition.HasCreateByWith(with...))
	}
	if i.HasUpdateBy != nil {
		p := orgunitposition.HasUpdateBy()
		if !*i.HasUpdateBy {
			p = orgunitposition.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasUpdateByWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasUpdateByWith))
		for _, w := range i.HasUpdateByWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, orgunitposition.HasUpdateByWith(with...))
	}
	if i.HasBelongToOrgUnitMembers != nil {
		p := orgunitposition.HasBelongToOrgUnitMembers()
		if !*i.HasBelongToOrgUnitMembers {
			p = orgunitposition.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasBelongToOrgUnitMembersWith) > 0 {
		with := make([]predicate.OrgUnitMember, 0, len(i.HasBelongToOrgUnitMembersWith))
		for _, w := range i.HasBelongToOrgUnitMembersWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, orgunitposition.HasBelongToOrgUnitMembersWith(with...))
	}
	if i.HasBelongToOrgUnit != nil {
		p := orgunitposition.HasBelongToOrgUnit()
		if !*i.HasBelongToOrgUnit {
			p = orgunitposition.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasBelongToOrgUnitWith) > 0 {
		with := make([]predicate.OrgUnit, 0, len(i.HasBelongToOrgUnitWith))
		for _, w := range i.HasBelongToOrgUnitWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, orgunitposition.HasBelongToOrgUnitWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, fmt.Errorf("wing/models/ent: empty predicate OrgUnitPositionWhereInput")
	case 1:
		return predicates[0], nil
	default:
		return orgunitposition.And(predicates...), nil
	}
}

// OrganizationWhereInput represents a where input for filtering Organization queries.
type OrganizationWhereInput struct {
	Not *OrganizationWhereInput   `json:"not,omitempty"`
	Or  []*OrganizationWhereInput `json:"or,omitempty"`
	And []*OrganizationWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "create_by_user" field predicates.
	CreateByUser       *int  `json:"createByUser,omitempty"`
	CreateByUserNEQ    *int  `json:"createByUserNEQ,omitempty"`
	CreateByUserIn     []int `json:"createByUserIn,omitempty"`
	CreateByUserNotIn  []int `json:"createByUserNotIn,omitempty"`
	CreateByUserIsNil  bool  `json:"createByUserIsNil,omitempty"`
	CreateByUserNotNil bool  `json:"createByUserNotNil,omitempty"`

	// "update_by_user" field predicates.
	UpdateByUser       *int  `json:"updateByUser,omitempty"`
	UpdateByUserNEQ    *int  `json:"updateByUserNEQ,omitempty"`
	UpdateByUserIn     []int `json:"updateByUserIn,omitempty"`
	UpdateByUserNotIn  []int `json:"updateByUserNotIn,omitempty"`
	UpdateByUserIsNil  bool  `json:"updateByUserIsNil,omitempty"`
	UpdateByUserNotNil bool  `json:"updateByUserNotNil,omitempty"`

	// "create_time" field predicates.
	CreateTime      *time.Time  `json:"createTime,omitempty"`
	CreateTimeNEQ   *time.Time  `json:"createTimeNEQ,omitempty"`
	CreateTimeIn    []time.Time `json:"createTimeIn,omitempty"`
	CreateTimeNotIn []time.Time `json:"createTimeNotIn,omitempty"`
	CreateTimeGT    *time.Time  `json:"createTimeGT,omitempty"`
	CreateTimeGTE   *time.Time  `json:"createTimeGTE,omitempty"`
	CreateTimeLT    *time.Time  `json:"createTimeLT,omitempty"`
	CreateTimeLTE   *time.Time  `json:"createTimeLTE,omitempty"`

	// "update_time" field predicates.
	UpdateTime       *time.Time  `json:"updateTime,omitempty"`
	UpdateTimeNEQ    *time.Time  `json:"updateTimeNEQ,omitempty"`
	UpdateTimeIn     []time.Time `json:"updateTimeIn,omitempty"`
	UpdateTimeNotIn  []time.Time `json:"updateTimeNotIn,omitempty"`
	UpdateTimeGT     *time.Time  `json:"updateTimeGT,omitempty"`
	UpdateTimeGTE    *time.Time  `json:"updateTimeGTE,omitempty"`
	UpdateTimeLT     *time.Time  `json:"updateTimeLT,omitempty"`
	UpdateTimeLTE    *time.Time  `json:"updateTimeLTE,omitempty"`
	UpdateTimeIsNil  bool        `json:"updateTimeIsNil,omitempty"`
	UpdateTimeNotNil bool        `json:"updateTimeNotNil,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "create_by" edge predicates.
	HasCreateBy     *bool             `json:"hasCreateBy,omitempty"`
	HasCreateByWith []*UserWhereInput `json:"hasCreateByWith,omitempty"`

	// "update_by" edge predicates.
	HasUpdateBy     *bool             `json:"hasUpdateBy,omitempty"`
	HasUpdateByWith []*UserWhereInput `json:"hasUpdateByWith,omitempty"`

	// "units" edge predicates.
	HasUnits     *bool                `json:"hasUnits,omitempty"`
	HasUnitsWith []*OrgUnitWhereInput `json:"hasUnitsWith,omitempty"`

	// "staffs" edge predicates.
	HasStaffs     *bool             `json:"hasStaffs,omitempty"`
	HasStaffsWith []*UserWhereInput `json:"hasStaffsWith,omitempty"`
}

// Filter applies the OrganizationWhereInput filter on the OrganizationQuery builder.
func (i *OrganizationWhereInput) Filter(q *OrganizationQuery) (*OrganizationQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		return nil, err
	}
	return q.Where(p), nil
}

// P returns a predicate for filtering organizations.
// An error is returned if the input is empty or invalid.
func (i *OrganizationWhereInput) P() (predicate.Organization, error) {
	var predicates []predicate.Organization
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, organization.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Organization, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			or = append(or, p)
		}
		predicates = append(predicates, organization.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Organization, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			and = append(and, p)
		}
		predicates = append(predicates, organization.And(and...))
	}
	if i.ID != nil {
		predicates = append(predicates, organization.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, organization.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, organization.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, organization.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, organization.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, organization.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, organization.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, organization.IDLTE(*i.IDLTE))
	}
	if i.CreateByUser != nil {
		predicates = append(predicates, organization.CreateByUserEQ(*i.CreateByUser))
	}
	if i.CreateByUserNEQ != nil {
		predicates = append(predicates, organization.CreateByUserNEQ(*i.CreateByUserNEQ))
	}
	if len(i.CreateByUserIn) > 0 {
		predicates = append(predicates, organization.CreateByUserIn(i.CreateByUserIn...))
	}
	if len(i.CreateByUserNotIn) > 0 {
		predicates = append(predicates, organization.CreateByUserNotIn(i.CreateByUserNotIn...))
	}
	if i.CreateByUserIsNil {
		predicates = append(predicates, organization.CreateByUserIsNil())
	}
	if i.CreateByUserNotNil {
		predicates = append(predicates, organization.CreateByUserNotNil())
	}
	if i.UpdateByUser != nil {
		predicates = append(predicates, organization.UpdateByUserEQ(*i.UpdateByUser))
	}
	if i.UpdateByUserNEQ != nil {
		predicates = append(predicates, organization.UpdateByUserNEQ(*i.UpdateByUserNEQ))
	}
	if len(i.UpdateByUserIn) > 0 {
		predicates = append(predicates, organization.UpdateByUserIn(i.UpdateByUserIn...))
	}
	if len(i.UpdateByUserNotIn) > 0 {
		predicates = append(predicates, organization.UpdateByUserNotIn(i.UpdateByUserNotIn...))
	}
	if i.UpdateByUserIsNil {
		predicates = append(predicates, organization.UpdateByUserIsNil())
	}
	if i.UpdateByUserNotNil {
		predicates = append(predicates, organization.UpdateByUserNotNil())
	}
	if i.CreateTime != nil {
		predicates = append(predicates, organization.CreateTimeEQ(*i.CreateTime))
	}
	if i.CreateTimeNEQ != nil {
		predicates = append(predicates, organization.CreateTimeNEQ(*i.CreateTimeNEQ))
	}
	if len(i.CreateTimeIn) > 0 {
		predicates = append(predicates, organization.CreateTimeIn(i.CreateTimeIn...))
	}
	if len(i.CreateTimeNotIn) > 0 {
		predicates = append(predicates, organization.CreateTimeNotIn(i.CreateTimeNotIn...))
	}
	if i.CreateTimeGT != nil {
		predicates = append(predicates, organization.CreateTimeGT(*i.CreateTimeGT))
	}
	if i.CreateTimeGTE != nil {
		predicates = append(predicates, organization.CreateTimeGTE(*i.CreateTimeGTE))
	}
	if i.CreateTimeLT != nil {
		predicates = append(predicates, organization.CreateTimeLT(*i.CreateTimeLT))
	}
	if i.CreateTimeLTE != nil {
		predicates = append(predicates, organization.CreateTimeLTE(*i.CreateTimeLTE))
	}
	if i.UpdateTime != nil {
		predicates = append(predicates, organization.UpdateTimeEQ(*i.UpdateTime))
	}
	if i.UpdateTimeNEQ != nil {
		predicates = append(predicates, organization.UpdateTimeNEQ(*i.UpdateTimeNEQ))
	}
	if len(i.UpdateTimeIn) > 0 {
		predicates = append(predicates, organization.UpdateTimeIn(i.UpdateTimeIn...))
	}
	if len(i.UpdateTimeNotIn) > 0 {
		predicates = append(predicates, organization.UpdateTimeNotIn(i.UpdateTimeNotIn...))
	}
	if i.UpdateTimeGT != nil {
		predicates = append(predicates, organization.UpdateTimeGT(*i.UpdateTimeGT))
	}
	if i.UpdateTimeGTE != nil {
		predicates = append(predicates, organization.UpdateTimeGTE(*i.UpdateTimeGTE))
	}
	if i.UpdateTimeLT != nil {
		predicates = append(predicates, organization.UpdateTimeLT(*i.UpdateTimeLT))
	}
	if i.UpdateTimeLTE != nil {
		predicates = append(predicates, organization.UpdateTimeLTE(*i.UpdateTimeLTE))
	}
	if i.UpdateTimeIsNil {
		predicates = append(predicates, organization.UpdateTimeIsNil())
	}
	if i.UpdateTimeNotNil {
		predicates = append(predicates, organization.UpdateTimeNotNil())
	}
	if i.Name != nil {
		predicates = append(predicates, organization.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, organization.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, organization.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, organization.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, organization.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, organization.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, organization.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, organization.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, organization.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, organization.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, organization.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, organization.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, organization.NameContainsFold(*i.NameContainsFold))
	}

	if i.HasCreateBy != nil {
		p := organization.HasCreateBy()
		if !*i.HasCreateBy {
			p = organization.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCreateByWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasCreateByWith))
		for _, w := range i.HasCreateByWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, organization.HasCreateByWith(with...))
	}
	if i.HasUpdateBy != nil {
		p := organization.HasUpdateBy()
		if !*i.HasUpdateBy {
			p = organization.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasUpdateByWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasUpdateByWith))
		for _, w := range i.HasUpdateByWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, organization.HasUpdateByWith(with...))
	}
	if i.HasUnits != nil {
		p := organization.HasUnits()
		if !*i.HasUnits {
			p = organization.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasUnitsWith) > 0 {
		with := make([]predicate.OrgUnit, 0, len(i.HasUnitsWith))
		for _, w := range i.HasUnitsWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, organization.HasUnitsWith(with...))
	}
	if i.HasStaffs != nil {
		p := organization.HasStaffs()
		if !*i.HasStaffs {
			p = organization.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasStaffsWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasStaffsWith))
		for _, w := range i.HasStaffsWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, organization.HasStaffsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, fmt.Errorf("wing/models/ent: empty predicate OrganizationWhereInput")
	case 1:
		return predicates[0], nil
	default:
		return organization.And(predicates...), nil
	}
}

// ResourceWhereInput represents a where input for filtering Resource queries.
type ResourceWhereInput struct {
	Not *ResourceWhereInput   `json:"not,omitempty"`
	Or  []*ResourceWhereInput `json:"or,omitempty"`
	And []*ResourceWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "type" field predicates.
	Type             *string  `json:"type,omitempty"`
	TypeNEQ          *string  `json:"typeNEQ,omitempty"`
	TypeIn           []string `json:"typeIn,omitempty"`
	TypeNotIn        []string `json:"typeNotIn,omitempty"`
	TypeGT           *string  `json:"typeGT,omitempty"`
	TypeGTE          *string  `json:"typeGTE,omitempty"`
	TypeLT           *string  `json:"typeLT,omitempty"`
	TypeLTE          *string  `json:"typeLTE,omitempty"`
	TypeContains     *string  `json:"typeContains,omitempty"`
	TypeHasPrefix    *string  `json:"typeHasPrefix,omitempty"`
	TypeHasSuffix    *string  `json:"typeHasSuffix,omitempty"`
	TypeEqualFold    *string  `json:"typeEqualFold,omitempty"`
	TypeContainsFold *string  `json:"typeContainsFold,omitempty"`
}

// Filter applies the ResourceWhereInput filter on the ResourceQuery builder.
func (i *ResourceWhereInput) Filter(q *ResourceQuery) (*ResourceQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		return nil, err
	}
	return q.Where(p), nil
}

// P returns a predicate for filtering resources.
// An error is returned if the input is empty or invalid.
func (i *ResourceWhereInput) P() (predicate.Resource, error) {
	var predicates []predicate.Resource
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, resource.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Resource, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			or = append(or, p)
		}
		predicates = append(predicates, resource.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Resource, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			and = append(and, p)
		}
		predicates = append(predicates, resource.And(and...))
	}
	if i.ID != nil {
		predicates = append(predicates, resource.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, resource.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, resource.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, resource.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, resource.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, resource.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, resource.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, resource.IDLTE(*i.IDLTE))
	}
	if i.Name != nil {
		predicates = append(predicates, resource.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, resource.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, resource.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, resource.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, resource.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, resource.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, resource.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, resource.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, resource.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, resource.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, resource.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, resource.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, resource.NameContainsFold(*i.NameContainsFold))
	}
	if i.Type != nil {
		predicates = append(predicates, resource.TypeEQ(*i.Type))
	}
	if i.TypeNEQ != nil {
		predicates = append(predicates, resource.TypeNEQ(*i.TypeNEQ))
	}
	if len(i.TypeIn) > 0 {
		predicates = append(predicates, resource.TypeIn(i.TypeIn...))
	}
	if len(i.TypeNotIn) > 0 {
		predicates = append(predicates, resource.TypeNotIn(i.TypeNotIn...))
	}
	if i.TypeGT != nil {
		predicates = append(predicates, resource.TypeGT(*i.TypeGT))
	}
	if i.TypeGTE != nil {
		predicates = append(predicates, resource.TypeGTE(*i.TypeGTE))
	}
	if i.TypeLT != nil {
		predicates = append(predicates, resource.TypeLT(*i.TypeLT))
	}
	if i.TypeLTE != nil {
		predicates = append(predicates, resource.TypeLTE(*i.TypeLTE))
	}
	if i.TypeContains != nil {
		predicates = append(predicates, resource.TypeContains(*i.TypeContains))
	}
	if i.TypeHasPrefix != nil {
		predicates = append(predicates, resource.TypeHasPrefix(*i.TypeHasPrefix))
	}
	if i.TypeHasSuffix != nil {
		predicates = append(predicates, resource.TypeHasSuffix(*i.TypeHasSuffix))
	}
	if i.TypeEqualFold != nil {
		predicates = append(predicates, resource.TypeEqualFold(*i.TypeEqualFold))
	}
	if i.TypeContainsFold != nil {
		predicates = append(predicates, resource.TypeContainsFold(*i.TypeContainsFold))
	}

	switch len(predicates) {
	case 0:
		return nil, fmt.Errorf("wing/models/ent: empty predicate ResourceWhereInput")
	case 1:
		return predicates[0], nil
	default:
		return resource.And(predicates...), nil
	}
}

// SystemWhereInput represents a where input for filtering System queries.
type SystemWhereInput struct {
	Not *SystemWhereInput   `json:"not,omitempty"`
	Or  []*SystemWhereInput `json:"or,omitempty"`
	And []*SystemWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "create_by_user" field predicates.
	CreateByUser       *int  `json:"createByUser,omitempty"`
	CreateByUserNEQ    *int  `json:"createByUserNEQ,omitempty"`
	CreateByUserIn     []int `json:"createByUserIn,omitempty"`
	CreateByUserNotIn  []int `json:"createByUserNotIn,omitempty"`
	CreateByUserIsNil  bool  `json:"createByUserIsNil,omitempty"`
	CreateByUserNotNil bool  `json:"createByUserNotNil,omitempty"`

	// "update_by_user" field predicates.
	UpdateByUser       *int  `json:"updateByUser,omitempty"`
	UpdateByUserNEQ    *int  `json:"updateByUserNEQ,omitempty"`
	UpdateByUserIn     []int `json:"updateByUserIn,omitempty"`
	UpdateByUserNotIn  []int `json:"updateByUserNotIn,omitempty"`
	UpdateByUserIsNil  bool  `json:"updateByUserIsNil,omitempty"`
	UpdateByUserNotNil bool  `json:"updateByUserNotNil,omitempty"`

	// "create_time" field predicates.
	CreateTime      *time.Time  `json:"createTime,omitempty"`
	CreateTimeNEQ   *time.Time  `json:"createTimeNEQ,omitempty"`
	CreateTimeIn    []time.Time `json:"createTimeIn,omitempty"`
	CreateTimeNotIn []time.Time `json:"createTimeNotIn,omitempty"`
	CreateTimeGT    *time.Time  `json:"createTimeGT,omitempty"`
	CreateTimeGTE   *time.Time  `json:"createTimeGTE,omitempty"`
	CreateTimeLT    *time.Time  `json:"createTimeLT,omitempty"`
	CreateTimeLTE   *time.Time  `json:"createTimeLTE,omitempty"`

	// "update_time" field predicates.
	UpdateTime       *time.Time  `json:"updateTime,omitempty"`
	UpdateTimeNEQ    *time.Time  `json:"updateTimeNEQ,omitempty"`
	UpdateTimeIn     []time.Time `json:"updateTimeIn,omitempty"`
	UpdateTimeNotIn  []time.Time `json:"updateTimeNotIn,omitempty"`
	UpdateTimeGT     *time.Time  `json:"updateTimeGT,omitempty"`
	UpdateTimeGTE    *time.Time  `json:"updateTimeGTE,omitempty"`
	UpdateTimeLT     *time.Time  `json:"updateTimeLT,omitempty"`
	UpdateTimeLTE    *time.Time  `json:"updateTimeLTE,omitempty"`
	UpdateTimeIsNil  bool        `json:"updateTimeIsNil,omitempty"`
	UpdateTimeNotNil bool        `json:"updateTimeNotNil,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "create_by" edge predicates.
	HasCreateBy     *bool             `json:"hasCreateBy,omitempty"`
	HasCreateByWith []*UserWhereInput `json:"hasCreateByWith,omitempty"`

	// "update_by" edge predicates.
	HasUpdateBy     *bool             `json:"hasUpdateBy,omitempty"`
	HasUpdateByWith []*UserWhereInput `json:"hasUpdateByWith,omitempty"`
}

// Filter applies the SystemWhereInput filter on the SystemQuery builder.
func (i *SystemWhereInput) Filter(q *SystemQuery) (*SystemQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		return nil, err
	}
	return q.Where(p), nil
}

// P returns a predicate for filtering systems.
// An error is returned if the input is empty or invalid.
func (i *SystemWhereInput) P() (predicate.System, error) {
	var predicates []predicate.System
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, system.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.System, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			or = append(or, p)
		}
		predicates = append(predicates, system.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.System, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			and = append(and, p)
		}
		predicates = append(predicates, system.And(and...))
	}
	if i.ID != nil {
		predicates = append(predicates, system.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, system.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, system.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, system.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, system.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, system.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, system.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, system.IDLTE(*i.IDLTE))
	}
	if i.CreateByUser != nil {
		predicates = append(predicates, system.CreateByUserEQ(*i.CreateByUser))
	}
	if i.CreateByUserNEQ != nil {
		predicates = append(predicates, system.CreateByUserNEQ(*i.CreateByUserNEQ))
	}
	if len(i.CreateByUserIn) > 0 {
		predicates = append(predicates, system.CreateByUserIn(i.CreateByUserIn...))
	}
	if len(i.CreateByUserNotIn) > 0 {
		predicates = append(predicates, system.CreateByUserNotIn(i.CreateByUserNotIn...))
	}
	if i.CreateByUserIsNil {
		predicates = append(predicates, system.CreateByUserIsNil())
	}
	if i.CreateByUserNotNil {
		predicates = append(predicates, system.CreateByUserNotNil())
	}
	if i.UpdateByUser != nil {
		predicates = append(predicates, system.UpdateByUserEQ(*i.UpdateByUser))
	}
	if i.UpdateByUserNEQ != nil {
		predicates = append(predicates, system.UpdateByUserNEQ(*i.UpdateByUserNEQ))
	}
	if len(i.UpdateByUserIn) > 0 {
		predicates = append(predicates, system.UpdateByUserIn(i.UpdateByUserIn...))
	}
	if len(i.UpdateByUserNotIn) > 0 {
		predicates = append(predicates, system.UpdateByUserNotIn(i.UpdateByUserNotIn...))
	}
	if i.UpdateByUserIsNil {
		predicates = append(predicates, system.UpdateByUserIsNil())
	}
	if i.UpdateByUserNotNil {
		predicates = append(predicates, system.UpdateByUserNotNil())
	}
	if i.CreateTime != nil {
		predicates = append(predicates, system.CreateTimeEQ(*i.CreateTime))
	}
	if i.CreateTimeNEQ != nil {
		predicates = append(predicates, system.CreateTimeNEQ(*i.CreateTimeNEQ))
	}
	if len(i.CreateTimeIn) > 0 {
		predicates = append(predicates, system.CreateTimeIn(i.CreateTimeIn...))
	}
	if len(i.CreateTimeNotIn) > 0 {
		predicates = append(predicates, system.CreateTimeNotIn(i.CreateTimeNotIn...))
	}
	if i.CreateTimeGT != nil {
		predicates = append(predicates, system.CreateTimeGT(*i.CreateTimeGT))
	}
	if i.CreateTimeGTE != nil {
		predicates = append(predicates, system.CreateTimeGTE(*i.CreateTimeGTE))
	}
	if i.CreateTimeLT != nil {
		predicates = append(predicates, system.CreateTimeLT(*i.CreateTimeLT))
	}
	if i.CreateTimeLTE != nil {
		predicates = append(predicates, system.CreateTimeLTE(*i.CreateTimeLTE))
	}
	if i.UpdateTime != nil {
		predicates = append(predicates, system.UpdateTimeEQ(*i.UpdateTime))
	}
	if i.UpdateTimeNEQ != nil {
		predicates = append(predicates, system.UpdateTimeNEQ(*i.UpdateTimeNEQ))
	}
	if len(i.UpdateTimeIn) > 0 {
		predicates = append(predicates, system.UpdateTimeIn(i.UpdateTimeIn...))
	}
	if len(i.UpdateTimeNotIn) > 0 {
		predicates = append(predicates, system.UpdateTimeNotIn(i.UpdateTimeNotIn...))
	}
	if i.UpdateTimeGT != nil {
		predicates = append(predicates, system.UpdateTimeGT(*i.UpdateTimeGT))
	}
	if i.UpdateTimeGTE != nil {
		predicates = append(predicates, system.UpdateTimeGTE(*i.UpdateTimeGTE))
	}
	if i.UpdateTimeLT != nil {
		predicates = append(predicates, system.UpdateTimeLT(*i.UpdateTimeLT))
	}
	if i.UpdateTimeLTE != nil {
		predicates = append(predicates, system.UpdateTimeLTE(*i.UpdateTimeLTE))
	}
	if i.UpdateTimeIsNil {
		predicates = append(predicates, system.UpdateTimeIsNil())
	}
	if i.UpdateTimeNotNil {
		predicates = append(predicates, system.UpdateTimeNotNil())
	}
	if i.Name != nil {
		predicates = append(predicates, system.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, system.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, system.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, system.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, system.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, system.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, system.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, system.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, system.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, system.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, system.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, system.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, system.NameContainsFold(*i.NameContainsFold))
	}

	if i.HasCreateBy != nil {
		p := system.HasCreateBy()
		if !*i.HasCreateBy {
			p = system.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCreateByWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasCreateByWith))
		for _, w := range i.HasCreateByWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, system.HasCreateByWith(with...))
	}
	if i.HasUpdateBy != nil {
		p := system.HasUpdateBy()
		if !*i.HasUpdateBy {
			p = system.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasUpdateByWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasUpdateByWith))
		for _, w := range i.HasUpdateByWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, system.HasUpdateByWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, fmt.Errorf("wing/models/ent: empty predicate SystemWhereInput")
	case 1:
		return predicates[0], nil
	default:
		return system.And(predicates...), nil
	}
}

// UserWhereInput represents a where input for filtering User queries.
type UserWhereInput struct {
	Not *UserWhereInput   `json:"not,omitempty"`
	Or  []*UserWhereInput `json:"or,omitempty"`
	And []*UserWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "create_by_user" field predicates.
	CreateByUser       *int  `json:"createByUser,omitempty"`
	CreateByUserNEQ    *int  `json:"createByUserNEQ,omitempty"`
	CreateByUserIn     []int `json:"createByUserIn,omitempty"`
	CreateByUserNotIn  []int `json:"createByUserNotIn,omitempty"`
	CreateByUserIsNil  bool  `json:"createByUserIsNil,omitempty"`
	CreateByUserNotNil bool  `json:"createByUserNotNil,omitempty"`

	// "update_by_user" field predicates.
	UpdateByUser       *int  `json:"updateByUser,omitempty"`
	UpdateByUserNEQ    *int  `json:"updateByUserNEQ,omitempty"`
	UpdateByUserIn     []int `json:"updateByUserIn,omitempty"`
	UpdateByUserNotIn  []int `json:"updateByUserNotIn,omitempty"`
	UpdateByUserIsNil  bool  `json:"updateByUserIsNil,omitempty"`
	UpdateByUserNotNil bool  `json:"updateByUserNotNil,omitempty"`

	// "create_time" field predicates.
	CreateTime      *time.Time  `json:"createTime,omitempty"`
	CreateTimeNEQ   *time.Time  `json:"createTimeNEQ,omitempty"`
	CreateTimeIn    []time.Time `json:"createTimeIn,omitempty"`
	CreateTimeNotIn []time.Time `json:"createTimeNotIn,omitempty"`
	CreateTimeGT    *time.Time  `json:"createTimeGT,omitempty"`
	CreateTimeGTE   *time.Time  `json:"createTimeGTE,omitempty"`
	CreateTimeLT    *time.Time  `json:"createTimeLT,omitempty"`
	CreateTimeLTE   *time.Time  `json:"createTimeLTE,omitempty"`

	// "update_time" field predicates.
	UpdateTime       *time.Time  `json:"updateTime,omitempty"`
	UpdateTimeNEQ    *time.Time  `json:"updateTimeNEQ,omitempty"`
	UpdateTimeIn     []time.Time `json:"updateTimeIn,omitempty"`
	UpdateTimeNotIn  []time.Time `json:"updateTimeNotIn,omitempty"`
	UpdateTimeGT     *time.Time  `json:"updateTimeGT,omitempty"`
	UpdateTimeGTE    *time.Time  `json:"updateTimeGTE,omitempty"`
	UpdateTimeLT     *time.Time  `json:"updateTimeLT,omitempty"`
	UpdateTimeLTE    *time.Time  `json:"updateTimeLTE,omitempty"`
	UpdateTimeIsNil  bool        `json:"updateTimeIsNil,omitempty"`
	UpdateTimeNotNil bool        `json:"updateTimeNotNil,omitempty"`

	// "account_name" field predicates.
	AccountName             *string  `json:"accountName,omitempty"`
	AccountNameNEQ          *string  `json:"accountNameNEQ,omitempty"`
	AccountNameIn           []string `json:"accountNameIn,omitempty"`
	AccountNameNotIn        []string `json:"accountNameNotIn,omitempty"`
	AccountNameGT           *string  `json:"accountNameGT,omitempty"`
	AccountNameGTE          *string  `json:"accountNameGTE,omitempty"`
	AccountNameLT           *string  `json:"accountNameLT,omitempty"`
	AccountNameLTE          *string  `json:"accountNameLTE,omitempty"`
	AccountNameContains     *string  `json:"accountNameContains,omitempty"`
	AccountNameHasPrefix    *string  `json:"accountNameHasPrefix,omitempty"`
	AccountNameHasSuffix    *string  `json:"accountNameHasSuffix,omitempty"`
	AccountNameEqualFold    *string  `json:"accountNameEqualFold,omitempty"`
	AccountNameContainsFold *string  `json:"accountNameContainsFold,omitempty"`

	// "staff_type" field predicates.
	StaffType      *user.StaffType  `json:"staffType,omitempty"`
	StaffTypeNEQ   *user.StaffType  `json:"staffTypeNEQ,omitempty"`
	StaffTypeIn    []user.StaffType `json:"staffTypeIn,omitempty"`
	StaffTypeNotIn []user.StaffType `json:"staffTypeNotIn,omitempty"`

	// "is_on_job" field predicates.
	IsOnJob    *bool `json:"isOnJob,omitempty"`
	IsOnJobNEQ *bool `json:"isOnJobNEQ,omitempty"`

	// "family_name" field predicates.
	FamilyName             *string  `json:"familyName,omitempty"`
	FamilyNameNEQ          *string  `json:"familyNameNEQ,omitempty"`
	FamilyNameIn           []string `json:"familyNameIn,omitempty"`
	FamilyNameNotIn        []string `json:"familyNameNotIn,omitempty"`
	FamilyNameGT           *string  `json:"familyNameGT,omitempty"`
	FamilyNameGTE          *string  `json:"familyNameGTE,omitempty"`
	FamilyNameLT           *string  `json:"familyNameLT,omitempty"`
	FamilyNameLTE          *string  `json:"familyNameLTE,omitempty"`
	FamilyNameContains     *string  `json:"familyNameContains,omitempty"`
	FamilyNameHasPrefix    *string  `json:"familyNameHasPrefix,omitempty"`
	FamilyNameHasSuffix    *string  `json:"familyNameHasSuffix,omitempty"`
	FamilyNameEqualFold    *string  `json:"familyNameEqualFold,omitempty"`
	FamilyNameContainsFold *string  `json:"familyNameContainsFold,omitempty"`

	// "given_name" field predicates.
	GivenName             *string  `json:"givenName,omitempty"`
	GivenNameNEQ          *string  `json:"givenNameNEQ,omitempty"`
	GivenNameIn           []string `json:"givenNameIn,omitempty"`
	GivenNameNotIn        []string `json:"givenNameNotIn,omitempty"`
	GivenNameGT           *string  `json:"givenNameGT,omitempty"`
	GivenNameGTE          *string  `json:"givenNameGTE,omitempty"`
	GivenNameLT           *string  `json:"givenNameLT,omitempty"`
	GivenNameLTE          *string  `json:"givenNameLTE,omitempty"`
	GivenNameContains     *string  `json:"givenNameContains,omitempty"`
	GivenNameHasPrefix    *string  `json:"givenNameHasPrefix,omitempty"`
	GivenNameHasSuffix    *string  `json:"givenNameHasSuffix,omitempty"`
	GivenNameEqualFold    *string  `json:"givenNameEqualFold,omitempty"`
	GivenNameContainsFold *string  `json:"givenNameContainsFold,omitempty"`

	// "display_name" field predicates.
	DisplayName             *string  `json:"displayName,omitempty"`
	DisplayNameNEQ          *string  `json:"displayNameNEQ,omitempty"`
	DisplayNameIn           []string `json:"displayNameIn,omitempty"`
	DisplayNameNotIn        []string `json:"displayNameNotIn,omitempty"`
	DisplayNameGT           *string  `json:"displayNameGT,omitempty"`
	DisplayNameGTE          *string  `json:"displayNameGTE,omitempty"`
	DisplayNameLT           *string  `json:"displayNameLT,omitempty"`
	DisplayNameLTE          *string  `json:"displayNameLTE,omitempty"`
	DisplayNameContains     *string  `json:"displayNameContains,omitempty"`
	DisplayNameHasPrefix    *string  `json:"displayNameHasPrefix,omitempty"`
	DisplayNameHasSuffix    *string  `json:"displayNameHasSuffix,omitempty"`
	DisplayNameEqualFold    *string  `json:"displayNameEqualFold,omitempty"`
	DisplayNameContainsFold *string  `json:"displayNameContainsFold,omitempty"`

	// "birthday" field predicates.
	Birthday       *time.Time  `json:"birthday,omitempty"`
	BirthdayNEQ    *time.Time  `json:"birthdayNEQ,omitempty"`
	BirthdayIn     []time.Time `json:"birthdayIn,omitempty"`
	BirthdayNotIn  []time.Time `json:"birthdayNotIn,omitempty"`
	BirthdayGT     *time.Time  `json:"birthdayGT,omitempty"`
	BirthdayGTE    *time.Time  `json:"birthdayGTE,omitempty"`
	BirthdayLT     *time.Time  `json:"birthdayLT,omitempty"`
	BirthdayLTE    *time.Time  `json:"birthdayLTE,omitempty"`
	BirthdayIsNil  bool        `json:"birthdayIsNil,omitempty"`
	BirthdayNotNil bool        `json:"birthdayNotNil,omitempty"`

	// "id_number" field predicates.
	IDNumber             *string  `json:"idNumber,omitempty"`
	IDNumberNEQ          *string  `json:"idNumberNEQ,omitempty"`
	IDNumberIn           []string `json:"idNumberIn,omitempty"`
	IDNumberNotIn        []string `json:"idNumberNotIn,omitempty"`
	IDNumberGT           *string  `json:"idNumberGT,omitempty"`
	IDNumberGTE          *string  `json:"idNumberGTE,omitempty"`
	IDNumberLT           *string  `json:"idNumberLT,omitempty"`
	IDNumberLTE          *string  `json:"idNumberLTE,omitempty"`
	IDNumberContains     *string  `json:"idNumberContains,omitempty"`
	IDNumberHasPrefix    *string  `json:"idNumberHasPrefix,omitempty"`
	IDNumberHasSuffix    *string  `json:"idNumberHasSuffix,omitempty"`
	IDNumberIsNil        bool     `json:"idNumberIsNil,omitempty"`
	IDNumberNotNil       bool     `json:"idNumberNotNil,omitempty"`
	IDNumberEqualFold    *string  `json:"idNumberEqualFold,omitempty"`
	IDNumberContainsFold *string  `json:"idNumberContainsFold,omitempty"`

	// "sex" field predicates.
	Sex       *user.Sex  `json:"sex,omitempty"`
	SexNEQ    *user.Sex  `json:"sexNEQ,omitempty"`
	SexIn     []user.Sex `json:"sexIn,omitempty"`
	SexNotIn  []user.Sex `json:"sexNotIn,omitempty"`
	SexIsNil  bool       `json:"sexIsNil,omitempty"`
	SexNotNil bool       `json:"sexNotNil,omitempty"`

	// "phone_number" field predicates.
	PhoneNumber             *string  `json:"phoneNumber,omitempty"`
	PhoneNumberNEQ          *string  `json:"phoneNumberNEQ,omitempty"`
	PhoneNumberIn           []string `json:"phoneNumberIn,omitempty"`
	PhoneNumberNotIn        []string `json:"phoneNumberNotIn,omitempty"`
	PhoneNumberGT           *string  `json:"phoneNumberGT,omitempty"`
	PhoneNumberGTE          *string  `json:"phoneNumberGTE,omitempty"`
	PhoneNumberLT           *string  `json:"phoneNumberLT,omitempty"`
	PhoneNumberLTE          *string  `json:"phoneNumberLTE,omitempty"`
	PhoneNumberContains     *string  `json:"phoneNumberContains,omitempty"`
	PhoneNumberHasPrefix    *string  `json:"phoneNumberHasPrefix,omitempty"`
	PhoneNumberHasSuffix    *string  `json:"phoneNumberHasSuffix,omitempty"`
	PhoneNumberIsNil        bool     `json:"phoneNumberIsNil,omitempty"`
	PhoneNumberNotNil       bool     `json:"phoneNumberNotNil,omitempty"`
	PhoneNumberEqualFold    *string  `json:"phoneNumberEqualFold,omitempty"`
	PhoneNumberContainsFold *string  `json:"phoneNumberContainsFold,omitempty"`

	// "address" field predicates.
	Address             *string  `json:"address,omitempty"`
	AddressNEQ          *string  `json:"addressNEQ,omitempty"`
	AddressIn           []string `json:"addressIn,omitempty"`
	AddressNotIn        []string `json:"addressNotIn,omitempty"`
	AddressGT           *string  `json:"addressGT,omitempty"`
	AddressGTE          *string  `json:"addressGTE,omitempty"`
	AddressLT           *string  `json:"addressLT,omitempty"`
	AddressLTE          *string  `json:"addressLTE,omitempty"`
	AddressContains     *string  `json:"addressContains,omitempty"`
	AddressHasPrefix    *string  `json:"addressHasPrefix,omitempty"`
	AddressHasSuffix    *string  `json:"addressHasSuffix,omitempty"`
	AddressIsNil        bool     `json:"addressIsNil,omitempty"`
	AddressNotNil       bool     `json:"addressNotNil,omitempty"`
	AddressEqualFold    *string  `json:"addressEqualFold,omitempty"`
	AddressContainsFold *string  `json:"addressContainsFold,omitempty"`

	// "staff_id" field predicates.
	StaffID             *string  `json:"staffID,omitempty"`
	StaffIDNEQ          *string  `json:"staffIDNEQ,omitempty"`
	StaffIDIn           []string `json:"staffIDIn,omitempty"`
	StaffIDNotIn        []string `json:"staffIDNotIn,omitempty"`
	StaffIDGT           *string  `json:"staffIDGT,omitempty"`
	StaffIDGTE          *string  `json:"staffIDGTE,omitempty"`
	StaffIDLT           *string  `json:"staffIDLT,omitempty"`
	StaffIDLTE          *string  `json:"staffIDLTE,omitempty"`
	StaffIDContains     *string  `json:"staffIDContains,omitempty"`
	StaffIDHasPrefix    *string  `json:"staffIDHasPrefix,omitempty"`
	StaffIDHasSuffix    *string  `json:"staffIDHasSuffix,omitempty"`
	StaffIDIsNil        bool     `json:"staffIDIsNil,omitempty"`
	StaffIDNotNil       bool     `json:"staffIDNotNil,omitempty"`
	StaffIDEqualFold    *string  `json:"staffIDEqualFold,omitempty"`
	StaffIDContainsFold *string  `json:"staffIDContainsFold,omitempty"`

	// "personal_email" field predicates.
	PersonalEmail             *string  `json:"personalEmail,omitempty"`
	PersonalEmailNEQ          *string  `json:"personalEmailNEQ,omitempty"`
	PersonalEmailIn           []string `json:"personalEmailIn,omitempty"`
	PersonalEmailNotIn        []string `json:"personalEmailNotIn,omitempty"`
	PersonalEmailGT           *string  `json:"personalEmailGT,omitempty"`
	PersonalEmailGTE          *string  `json:"personalEmailGTE,omitempty"`
	PersonalEmailLT           *string  `json:"personalEmailLT,omitempty"`
	PersonalEmailLTE          *string  `json:"personalEmailLTE,omitempty"`
	PersonalEmailContains     *string  `json:"personalEmailContains,omitempty"`
	PersonalEmailHasPrefix    *string  `json:"personalEmailHasPrefix,omitempty"`
	PersonalEmailHasSuffix    *string  `json:"personalEmailHasSuffix,omitempty"`
	PersonalEmailIsNil        bool     `json:"personalEmailIsNil,omitempty"`
	PersonalEmailNotNil       bool     `json:"personalEmailNotNil,omitempty"`
	PersonalEmailEqualFold    *string  `json:"personalEmailEqualFold,omitempty"`
	PersonalEmailContainsFold *string  `json:"personalEmailContainsFold,omitempty"`

	// "intranet_work_email" field predicates.
	IntranetWorkEmail             *string  `json:"intranetWorkEmail,omitempty"`
	IntranetWorkEmailNEQ          *string  `json:"intranetWorkEmailNEQ,omitempty"`
	IntranetWorkEmailIn           []string `json:"intranetWorkEmailIn,omitempty"`
	IntranetWorkEmailNotIn        []string `json:"intranetWorkEmailNotIn,omitempty"`
	IntranetWorkEmailGT           *string  `json:"intranetWorkEmailGT,omitempty"`
	IntranetWorkEmailGTE          *string  `json:"intranetWorkEmailGTE,omitempty"`
	IntranetWorkEmailLT           *string  `json:"intranetWorkEmailLT,omitempty"`
	IntranetWorkEmailLTE          *string  `json:"intranetWorkEmailLTE,omitempty"`
	IntranetWorkEmailContains     *string  `json:"intranetWorkEmailContains,omitempty"`
	IntranetWorkEmailHasPrefix    *string  `json:"intranetWorkEmailHasPrefix,omitempty"`
	IntranetWorkEmailHasSuffix    *string  `json:"intranetWorkEmailHasSuffix,omitempty"`
	IntranetWorkEmailEqualFold    *string  `json:"intranetWorkEmailEqualFold,omitempty"`
	IntranetWorkEmailContainsFold *string  `json:"intranetWorkEmailContainsFold,omitempty"`

	// "extranet_work_email" field predicates.
	ExtranetWorkEmail             *string  `json:"extranetWorkEmail,omitempty"`
	ExtranetWorkEmailNEQ          *string  `json:"extranetWorkEmailNEQ,omitempty"`
	ExtranetWorkEmailIn           []string `json:"extranetWorkEmailIn,omitempty"`
	ExtranetWorkEmailNotIn        []string `json:"extranetWorkEmailNotIn,omitempty"`
	ExtranetWorkEmailGT           *string  `json:"extranetWorkEmailGT,omitempty"`
	ExtranetWorkEmailGTE          *string  `json:"extranetWorkEmailGTE,omitempty"`
	ExtranetWorkEmailLT           *string  `json:"extranetWorkEmailLT,omitempty"`
	ExtranetWorkEmailLTE          *string  `json:"extranetWorkEmailLTE,omitempty"`
	ExtranetWorkEmailContains     *string  `json:"extranetWorkEmailContains,omitempty"`
	ExtranetWorkEmailHasPrefix    *string  `json:"extranetWorkEmailHasPrefix,omitempty"`
	ExtranetWorkEmailHasSuffix    *string  `json:"extranetWorkEmailHasSuffix,omitempty"`
	ExtranetWorkEmailIsNil        bool     `json:"extranetWorkEmailIsNil,omitempty"`
	ExtranetWorkEmailNotNil       bool     `json:"extranetWorkEmailNotNil,omitempty"`
	ExtranetWorkEmailEqualFold    *string  `json:"extranetWorkEmailEqualFold,omitempty"`
	ExtranetWorkEmailContainsFold *string  `json:"extranetWorkEmailContainsFold,omitempty"`

	// "create_by" edge predicates.
	HasCreateBy     *bool             `json:"hasCreateBy,omitempty"`
	HasCreateByWith []*UserWhereInput `json:"hasCreateByWith,omitempty"`

	// "update_by" edge predicates.
	HasUpdateBy     *bool             `json:"hasUpdateBy,omitempty"`
	HasUpdateByWith []*UserWhereInput `json:"hasUpdateByWith,omitempty"`

	// "authHistories" edge predicates.
	HasAuthHistories     *bool             `json:"hasAuthHistories,omitempty"`
	HasAuthHistoriesWith []*AuthWhereInput `json:"hasAuthHistoriesWith,omitempty"`

	// "jobHistories" edge predicates.
	HasJobHistories     *bool                   `json:"hasJobHistories,omitempty"`
	HasJobHistoriesWith []*JobHistoryWhereInput `json:"hasJobHistoriesWith,omitempty"`

	// "creates" edge predicates.
	HasCreates     *bool             `json:"hasCreates,omitempty"`
	HasCreatesWith []*UserWhereInput `json:"hasCreatesWith,omitempty"`

	// "updates" edge predicates.
	HasUpdates     *bool             `json:"hasUpdates,omitempty"`
	HasUpdatesWith []*UserWhereInput `json:"hasUpdatesWith,omitempty"`

	// "belongToOrgUnitMembers" edge predicates.
	HasBelongToOrgUnitMembers     *bool                      `json:"hasBelongToOrgUnitMembers,omitempty"`
	HasBelongToOrgUnitMembersWith []*OrgUnitMemberWhereInput `json:"hasBelongToOrgUnitMembersWith,omitempty"`

	// "belongToOg" edge predicates.
	HasBelongToOg     *bool                     `json:"hasBelongToOg,omitempty"`
	HasBelongToOgWith []*OrganizationWhereInput `json:"hasBelongToOgWith,omitempty"`
}

// Filter applies the UserWhereInput filter on the UserQuery builder.
func (i *UserWhereInput) Filter(q *UserQuery) (*UserQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		return nil, err
	}
	return q.Where(p), nil
}

// P returns a predicate for filtering users.
// An error is returned if the input is empty or invalid.
func (i *UserWhereInput) P() (predicate.User, error) {
	var predicates []predicate.User
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, user.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.User, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			or = append(or, p)
		}
		predicates = append(predicates, user.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.User, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			and = append(and, p)
		}
		predicates = append(predicates, user.And(and...))
	}
	if i.ID != nil {
		predicates = append(predicates, user.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, user.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, user.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, user.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, user.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, user.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, user.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, user.IDLTE(*i.IDLTE))
	}
	if i.CreateByUser != nil {
		predicates = append(predicates, user.CreateByUserEQ(*i.CreateByUser))
	}
	if i.CreateByUserNEQ != nil {
		predicates = append(predicates, user.CreateByUserNEQ(*i.CreateByUserNEQ))
	}
	if len(i.CreateByUserIn) > 0 {
		predicates = append(predicates, user.CreateByUserIn(i.CreateByUserIn...))
	}
	if len(i.CreateByUserNotIn) > 0 {
		predicates = append(predicates, user.CreateByUserNotIn(i.CreateByUserNotIn...))
	}
	if i.CreateByUserIsNil {
		predicates = append(predicates, user.CreateByUserIsNil())
	}
	if i.CreateByUserNotNil {
		predicates = append(predicates, user.CreateByUserNotNil())
	}
	if i.UpdateByUser != nil {
		predicates = append(predicates, user.UpdateByUserEQ(*i.UpdateByUser))
	}
	if i.UpdateByUserNEQ != nil {
		predicates = append(predicates, user.UpdateByUserNEQ(*i.UpdateByUserNEQ))
	}
	if len(i.UpdateByUserIn) > 0 {
		predicates = append(predicates, user.UpdateByUserIn(i.UpdateByUserIn...))
	}
	if len(i.UpdateByUserNotIn) > 0 {
		predicates = append(predicates, user.UpdateByUserNotIn(i.UpdateByUserNotIn...))
	}
	if i.UpdateByUserIsNil {
		predicates = append(predicates, user.UpdateByUserIsNil())
	}
	if i.UpdateByUserNotNil {
		predicates = append(predicates, user.UpdateByUserNotNil())
	}
	if i.CreateTime != nil {
		predicates = append(predicates, user.CreateTimeEQ(*i.CreateTime))
	}
	if i.CreateTimeNEQ != nil {
		predicates = append(predicates, user.CreateTimeNEQ(*i.CreateTimeNEQ))
	}
	if len(i.CreateTimeIn) > 0 {
		predicates = append(predicates, user.CreateTimeIn(i.CreateTimeIn...))
	}
	if len(i.CreateTimeNotIn) > 0 {
		predicates = append(predicates, user.CreateTimeNotIn(i.CreateTimeNotIn...))
	}
	if i.CreateTimeGT != nil {
		predicates = append(predicates, user.CreateTimeGT(*i.CreateTimeGT))
	}
	if i.CreateTimeGTE != nil {
		predicates = append(predicates, user.CreateTimeGTE(*i.CreateTimeGTE))
	}
	if i.CreateTimeLT != nil {
		predicates = append(predicates, user.CreateTimeLT(*i.CreateTimeLT))
	}
	if i.CreateTimeLTE != nil {
		predicates = append(predicates, user.CreateTimeLTE(*i.CreateTimeLTE))
	}
	if i.UpdateTime != nil {
		predicates = append(predicates, user.UpdateTimeEQ(*i.UpdateTime))
	}
	if i.UpdateTimeNEQ != nil {
		predicates = append(predicates, user.UpdateTimeNEQ(*i.UpdateTimeNEQ))
	}
	if len(i.UpdateTimeIn) > 0 {
		predicates = append(predicates, user.UpdateTimeIn(i.UpdateTimeIn...))
	}
	if len(i.UpdateTimeNotIn) > 0 {
		predicates = append(predicates, user.UpdateTimeNotIn(i.UpdateTimeNotIn...))
	}
	if i.UpdateTimeGT != nil {
		predicates = append(predicates, user.UpdateTimeGT(*i.UpdateTimeGT))
	}
	if i.UpdateTimeGTE != nil {
		predicates = append(predicates, user.UpdateTimeGTE(*i.UpdateTimeGTE))
	}
	if i.UpdateTimeLT != nil {
		predicates = append(predicates, user.UpdateTimeLT(*i.UpdateTimeLT))
	}
	if i.UpdateTimeLTE != nil {
		predicates = append(predicates, user.UpdateTimeLTE(*i.UpdateTimeLTE))
	}
	if i.UpdateTimeIsNil {
		predicates = append(predicates, user.UpdateTimeIsNil())
	}
	if i.UpdateTimeNotNil {
		predicates = append(predicates, user.UpdateTimeNotNil())
	}
	if i.AccountName != nil {
		predicates = append(predicates, user.AccountNameEQ(*i.AccountName))
	}
	if i.AccountNameNEQ != nil {
		predicates = append(predicates, user.AccountNameNEQ(*i.AccountNameNEQ))
	}
	if len(i.AccountNameIn) > 0 {
		predicates = append(predicates, user.AccountNameIn(i.AccountNameIn...))
	}
	if len(i.AccountNameNotIn) > 0 {
		predicates = append(predicates, user.AccountNameNotIn(i.AccountNameNotIn...))
	}
	if i.AccountNameGT != nil {
		predicates = append(predicates, user.AccountNameGT(*i.AccountNameGT))
	}
	if i.AccountNameGTE != nil {
		predicates = append(predicates, user.AccountNameGTE(*i.AccountNameGTE))
	}
	if i.AccountNameLT != nil {
		predicates = append(predicates, user.AccountNameLT(*i.AccountNameLT))
	}
	if i.AccountNameLTE != nil {
		predicates = append(predicates, user.AccountNameLTE(*i.AccountNameLTE))
	}
	if i.AccountNameContains != nil {
		predicates = append(predicates, user.AccountNameContains(*i.AccountNameContains))
	}
	if i.AccountNameHasPrefix != nil {
		predicates = append(predicates, user.AccountNameHasPrefix(*i.AccountNameHasPrefix))
	}
	if i.AccountNameHasSuffix != nil {
		predicates = append(predicates, user.AccountNameHasSuffix(*i.AccountNameHasSuffix))
	}
	if i.AccountNameEqualFold != nil {
		predicates = append(predicates, user.AccountNameEqualFold(*i.AccountNameEqualFold))
	}
	if i.AccountNameContainsFold != nil {
		predicates = append(predicates, user.AccountNameContainsFold(*i.AccountNameContainsFold))
	}
	if i.StaffType != nil {
		predicates = append(predicates, user.StaffTypeEQ(*i.StaffType))
	}
	if i.StaffTypeNEQ != nil {
		predicates = append(predicates, user.StaffTypeNEQ(*i.StaffTypeNEQ))
	}
	if len(i.StaffTypeIn) > 0 {
		predicates = append(predicates, user.StaffTypeIn(i.StaffTypeIn...))
	}
	if len(i.StaffTypeNotIn) > 0 {
		predicates = append(predicates, user.StaffTypeNotIn(i.StaffTypeNotIn...))
	}
	if i.IsOnJob != nil {
		predicates = append(predicates, user.IsOnJobEQ(*i.IsOnJob))
	}
	if i.IsOnJobNEQ != nil {
		predicates = append(predicates, user.IsOnJobNEQ(*i.IsOnJobNEQ))
	}
	if i.FamilyName != nil {
		predicates = append(predicates, user.FamilyNameEQ(*i.FamilyName))
	}
	if i.FamilyNameNEQ != nil {
		predicates = append(predicates, user.FamilyNameNEQ(*i.FamilyNameNEQ))
	}
	if len(i.FamilyNameIn) > 0 {
		predicates = append(predicates, user.FamilyNameIn(i.FamilyNameIn...))
	}
	if len(i.FamilyNameNotIn) > 0 {
		predicates = append(predicates, user.FamilyNameNotIn(i.FamilyNameNotIn...))
	}
	if i.FamilyNameGT != nil {
		predicates = append(predicates, user.FamilyNameGT(*i.FamilyNameGT))
	}
	if i.FamilyNameGTE != nil {
		predicates = append(predicates, user.FamilyNameGTE(*i.FamilyNameGTE))
	}
	if i.FamilyNameLT != nil {
		predicates = append(predicates, user.FamilyNameLT(*i.FamilyNameLT))
	}
	if i.FamilyNameLTE != nil {
		predicates = append(predicates, user.FamilyNameLTE(*i.FamilyNameLTE))
	}
	if i.FamilyNameContains != nil {
		predicates = append(predicates, user.FamilyNameContains(*i.FamilyNameContains))
	}
	if i.FamilyNameHasPrefix != nil {
		predicates = append(predicates, user.FamilyNameHasPrefix(*i.FamilyNameHasPrefix))
	}
	if i.FamilyNameHasSuffix != nil {
		predicates = append(predicates, user.FamilyNameHasSuffix(*i.FamilyNameHasSuffix))
	}
	if i.FamilyNameEqualFold != nil {
		predicates = append(predicates, user.FamilyNameEqualFold(*i.FamilyNameEqualFold))
	}
	if i.FamilyNameContainsFold != nil {
		predicates = append(predicates, user.FamilyNameContainsFold(*i.FamilyNameContainsFold))
	}
	if i.GivenName != nil {
		predicates = append(predicates, user.GivenNameEQ(*i.GivenName))
	}
	if i.GivenNameNEQ != nil {
		predicates = append(predicates, user.GivenNameNEQ(*i.GivenNameNEQ))
	}
	if len(i.GivenNameIn) > 0 {
		predicates = append(predicates, user.GivenNameIn(i.GivenNameIn...))
	}
	if len(i.GivenNameNotIn) > 0 {
		predicates = append(predicates, user.GivenNameNotIn(i.GivenNameNotIn...))
	}
	if i.GivenNameGT != nil {
		predicates = append(predicates, user.GivenNameGT(*i.GivenNameGT))
	}
	if i.GivenNameGTE != nil {
		predicates = append(predicates, user.GivenNameGTE(*i.GivenNameGTE))
	}
	if i.GivenNameLT != nil {
		predicates = append(predicates, user.GivenNameLT(*i.GivenNameLT))
	}
	if i.GivenNameLTE != nil {
		predicates = append(predicates, user.GivenNameLTE(*i.GivenNameLTE))
	}
	if i.GivenNameContains != nil {
		predicates = append(predicates, user.GivenNameContains(*i.GivenNameContains))
	}
	if i.GivenNameHasPrefix != nil {
		predicates = append(predicates, user.GivenNameHasPrefix(*i.GivenNameHasPrefix))
	}
	if i.GivenNameHasSuffix != nil {
		predicates = append(predicates, user.GivenNameHasSuffix(*i.GivenNameHasSuffix))
	}
	if i.GivenNameEqualFold != nil {
		predicates = append(predicates, user.GivenNameEqualFold(*i.GivenNameEqualFold))
	}
	if i.GivenNameContainsFold != nil {
		predicates = append(predicates, user.GivenNameContainsFold(*i.GivenNameContainsFold))
	}
	if i.DisplayName != nil {
		predicates = append(predicates, user.DisplayNameEQ(*i.DisplayName))
	}
	if i.DisplayNameNEQ != nil {
		predicates = append(predicates, user.DisplayNameNEQ(*i.DisplayNameNEQ))
	}
	if len(i.DisplayNameIn) > 0 {
		predicates = append(predicates, user.DisplayNameIn(i.DisplayNameIn...))
	}
	if len(i.DisplayNameNotIn) > 0 {
		predicates = append(predicates, user.DisplayNameNotIn(i.DisplayNameNotIn...))
	}
	if i.DisplayNameGT != nil {
		predicates = append(predicates, user.DisplayNameGT(*i.DisplayNameGT))
	}
	if i.DisplayNameGTE != nil {
		predicates = append(predicates, user.DisplayNameGTE(*i.DisplayNameGTE))
	}
	if i.DisplayNameLT != nil {
		predicates = append(predicates, user.DisplayNameLT(*i.DisplayNameLT))
	}
	if i.DisplayNameLTE != nil {
		predicates = append(predicates, user.DisplayNameLTE(*i.DisplayNameLTE))
	}
	if i.DisplayNameContains != nil {
		predicates = append(predicates, user.DisplayNameContains(*i.DisplayNameContains))
	}
	if i.DisplayNameHasPrefix != nil {
		predicates = append(predicates, user.DisplayNameHasPrefix(*i.DisplayNameHasPrefix))
	}
	if i.DisplayNameHasSuffix != nil {
		predicates = append(predicates, user.DisplayNameHasSuffix(*i.DisplayNameHasSuffix))
	}
	if i.DisplayNameEqualFold != nil {
		predicates = append(predicates, user.DisplayNameEqualFold(*i.DisplayNameEqualFold))
	}
	if i.DisplayNameContainsFold != nil {
		predicates = append(predicates, user.DisplayNameContainsFold(*i.DisplayNameContainsFold))
	}
	if i.Birthday != nil {
		predicates = append(predicates, user.BirthdayEQ(*i.Birthday))
	}
	if i.BirthdayNEQ != nil {
		predicates = append(predicates, user.BirthdayNEQ(*i.BirthdayNEQ))
	}
	if len(i.BirthdayIn) > 0 {
		predicates = append(predicates, user.BirthdayIn(i.BirthdayIn...))
	}
	if len(i.BirthdayNotIn) > 0 {
		predicates = append(predicates, user.BirthdayNotIn(i.BirthdayNotIn...))
	}
	if i.BirthdayGT != nil {
		predicates = append(predicates, user.BirthdayGT(*i.BirthdayGT))
	}
	if i.BirthdayGTE != nil {
		predicates = append(predicates, user.BirthdayGTE(*i.BirthdayGTE))
	}
	if i.BirthdayLT != nil {
		predicates = append(predicates, user.BirthdayLT(*i.BirthdayLT))
	}
	if i.BirthdayLTE != nil {
		predicates = append(predicates, user.BirthdayLTE(*i.BirthdayLTE))
	}
	if i.BirthdayIsNil {
		predicates = append(predicates, user.BirthdayIsNil())
	}
	if i.BirthdayNotNil {
		predicates = append(predicates, user.BirthdayNotNil())
	}
	if i.IDNumber != nil {
		predicates = append(predicates, user.IDNumberEQ(*i.IDNumber))
	}
	if i.IDNumberNEQ != nil {
		predicates = append(predicates, user.IDNumberNEQ(*i.IDNumberNEQ))
	}
	if len(i.IDNumberIn) > 0 {
		predicates = append(predicates, user.IDNumberIn(i.IDNumberIn...))
	}
	if len(i.IDNumberNotIn) > 0 {
		predicates = append(predicates, user.IDNumberNotIn(i.IDNumberNotIn...))
	}
	if i.IDNumberGT != nil {
		predicates = append(predicates, user.IDNumberGT(*i.IDNumberGT))
	}
	if i.IDNumberGTE != nil {
		predicates = append(predicates, user.IDNumberGTE(*i.IDNumberGTE))
	}
	if i.IDNumberLT != nil {
		predicates = append(predicates, user.IDNumberLT(*i.IDNumberLT))
	}
	if i.IDNumberLTE != nil {
		predicates = append(predicates, user.IDNumberLTE(*i.IDNumberLTE))
	}
	if i.IDNumberContains != nil {
		predicates = append(predicates, user.IDNumberContains(*i.IDNumberContains))
	}
	if i.IDNumberHasPrefix != nil {
		predicates = append(predicates, user.IDNumberHasPrefix(*i.IDNumberHasPrefix))
	}
	if i.IDNumberHasSuffix != nil {
		predicates = append(predicates, user.IDNumberHasSuffix(*i.IDNumberHasSuffix))
	}
	if i.IDNumberIsNil {
		predicates = append(predicates, user.IDNumberIsNil())
	}
	if i.IDNumberNotNil {
		predicates = append(predicates, user.IDNumberNotNil())
	}
	if i.IDNumberEqualFold != nil {
		predicates = append(predicates, user.IDNumberEqualFold(*i.IDNumberEqualFold))
	}
	if i.IDNumberContainsFold != nil {
		predicates = append(predicates, user.IDNumberContainsFold(*i.IDNumberContainsFold))
	}
	if i.Sex != nil {
		predicates = append(predicates, user.SexEQ(*i.Sex))
	}
	if i.SexNEQ != nil {
		predicates = append(predicates, user.SexNEQ(*i.SexNEQ))
	}
	if len(i.SexIn) > 0 {
		predicates = append(predicates, user.SexIn(i.SexIn...))
	}
	if len(i.SexNotIn) > 0 {
		predicates = append(predicates, user.SexNotIn(i.SexNotIn...))
	}
	if i.SexIsNil {
		predicates = append(predicates, user.SexIsNil())
	}
	if i.SexNotNil {
		predicates = append(predicates, user.SexNotNil())
	}
	if i.PhoneNumber != nil {
		predicates = append(predicates, user.PhoneNumberEQ(*i.PhoneNumber))
	}
	if i.PhoneNumberNEQ != nil {
		predicates = append(predicates, user.PhoneNumberNEQ(*i.PhoneNumberNEQ))
	}
	if len(i.PhoneNumberIn) > 0 {
		predicates = append(predicates, user.PhoneNumberIn(i.PhoneNumberIn...))
	}
	if len(i.PhoneNumberNotIn) > 0 {
		predicates = append(predicates, user.PhoneNumberNotIn(i.PhoneNumberNotIn...))
	}
	if i.PhoneNumberGT != nil {
		predicates = append(predicates, user.PhoneNumberGT(*i.PhoneNumberGT))
	}
	if i.PhoneNumberGTE != nil {
		predicates = append(predicates, user.PhoneNumberGTE(*i.PhoneNumberGTE))
	}
	if i.PhoneNumberLT != nil {
		predicates = append(predicates, user.PhoneNumberLT(*i.PhoneNumberLT))
	}
	if i.PhoneNumberLTE != nil {
		predicates = append(predicates, user.PhoneNumberLTE(*i.PhoneNumberLTE))
	}
	if i.PhoneNumberContains != nil {
		predicates = append(predicates, user.PhoneNumberContains(*i.PhoneNumberContains))
	}
	if i.PhoneNumberHasPrefix != nil {
		predicates = append(predicates, user.PhoneNumberHasPrefix(*i.PhoneNumberHasPrefix))
	}
	if i.PhoneNumberHasSuffix != nil {
		predicates = append(predicates, user.PhoneNumberHasSuffix(*i.PhoneNumberHasSuffix))
	}
	if i.PhoneNumberIsNil {
		predicates = append(predicates, user.PhoneNumberIsNil())
	}
	if i.PhoneNumberNotNil {
		predicates = append(predicates, user.PhoneNumberNotNil())
	}
	if i.PhoneNumberEqualFold != nil {
		predicates = append(predicates, user.PhoneNumberEqualFold(*i.PhoneNumberEqualFold))
	}
	if i.PhoneNumberContainsFold != nil {
		predicates = append(predicates, user.PhoneNumberContainsFold(*i.PhoneNumberContainsFold))
	}
	if i.Address != nil {
		predicates = append(predicates, user.AddressEQ(*i.Address))
	}
	if i.AddressNEQ != nil {
		predicates = append(predicates, user.AddressNEQ(*i.AddressNEQ))
	}
	if len(i.AddressIn) > 0 {
		predicates = append(predicates, user.AddressIn(i.AddressIn...))
	}
	if len(i.AddressNotIn) > 0 {
		predicates = append(predicates, user.AddressNotIn(i.AddressNotIn...))
	}
	if i.AddressGT != nil {
		predicates = append(predicates, user.AddressGT(*i.AddressGT))
	}
	if i.AddressGTE != nil {
		predicates = append(predicates, user.AddressGTE(*i.AddressGTE))
	}
	if i.AddressLT != nil {
		predicates = append(predicates, user.AddressLT(*i.AddressLT))
	}
	if i.AddressLTE != nil {
		predicates = append(predicates, user.AddressLTE(*i.AddressLTE))
	}
	if i.AddressContains != nil {
		predicates = append(predicates, user.AddressContains(*i.AddressContains))
	}
	if i.AddressHasPrefix != nil {
		predicates = append(predicates, user.AddressHasPrefix(*i.AddressHasPrefix))
	}
	if i.AddressHasSuffix != nil {
		predicates = append(predicates, user.AddressHasSuffix(*i.AddressHasSuffix))
	}
	if i.AddressIsNil {
		predicates = append(predicates, user.AddressIsNil())
	}
	if i.AddressNotNil {
		predicates = append(predicates, user.AddressNotNil())
	}
	if i.AddressEqualFold != nil {
		predicates = append(predicates, user.AddressEqualFold(*i.AddressEqualFold))
	}
	if i.AddressContainsFold != nil {
		predicates = append(predicates, user.AddressContainsFold(*i.AddressContainsFold))
	}
	if i.StaffID != nil {
		predicates = append(predicates, user.StaffIDEQ(*i.StaffID))
	}
	if i.StaffIDNEQ != nil {
		predicates = append(predicates, user.StaffIDNEQ(*i.StaffIDNEQ))
	}
	if len(i.StaffIDIn) > 0 {
		predicates = append(predicates, user.StaffIDIn(i.StaffIDIn...))
	}
	if len(i.StaffIDNotIn) > 0 {
		predicates = append(predicates, user.StaffIDNotIn(i.StaffIDNotIn...))
	}
	if i.StaffIDGT != nil {
		predicates = append(predicates, user.StaffIDGT(*i.StaffIDGT))
	}
	if i.StaffIDGTE != nil {
		predicates = append(predicates, user.StaffIDGTE(*i.StaffIDGTE))
	}
	if i.StaffIDLT != nil {
		predicates = append(predicates, user.StaffIDLT(*i.StaffIDLT))
	}
	if i.StaffIDLTE != nil {
		predicates = append(predicates, user.StaffIDLTE(*i.StaffIDLTE))
	}
	if i.StaffIDContains != nil {
		predicates = append(predicates, user.StaffIDContains(*i.StaffIDContains))
	}
	if i.StaffIDHasPrefix != nil {
		predicates = append(predicates, user.StaffIDHasPrefix(*i.StaffIDHasPrefix))
	}
	if i.StaffIDHasSuffix != nil {
		predicates = append(predicates, user.StaffIDHasSuffix(*i.StaffIDHasSuffix))
	}
	if i.StaffIDIsNil {
		predicates = append(predicates, user.StaffIDIsNil())
	}
	if i.StaffIDNotNil {
		predicates = append(predicates, user.StaffIDNotNil())
	}
	if i.StaffIDEqualFold != nil {
		predicates = append(predicates, user.StaffIDEqualFold(*i.StaffIDEqualFold))
	}
	if i.StaffIDContainsFold != nil {
		predicates = append(predicates, user.StaffIDContainsFold(*i.StaffIDContainsFold))
	}
	if i.PersonalEmail != nil {
		predicates = append(predicates, user.PersonalEmailEQ(*i.PersonalEmail))
	}
	if i.PersonalEmailNEQ != nil {
		predicates = append(predicates, user.PersonalEmailNEQ(*i.PersonalEmailNEQ))
	}
	if len(i.PersonalEmailIn) > 0 {
		predicates = append(predicates, user.PersonalEmailIn(i.PersonalEmailIn...))
	}
	if len(i.PersonalEmailNotIn) > 0 {
		predicates = append(predicates, user.PersonalEmailNotIn(i.PersonalEmailNotIn...))
	}
	if i.PersonalEmailGT != nil {
		predicates = append(predicates, user.PersonalEmailGT(*i.PersonalEmailGT))
	}
	if i.PersonalEmailGTE != nil {
		predicates = append(predicates, user.PersonalEmailGTE(*i.PersonalEmailGTE))
	}
	if i.PersonalEmailLT != nil {
		predicates = append(predicates, user.PersonalEmailLT(*i.PersonalEmailLT))
	}
	if i.PersonalEmailLTE != nil {
		predicates = append(predicates, user.PersonalEmailLTE(*i.PersonalEmailLTE))
	}
	if i.PersonalEmailContains != nil {
		predicates = append(predicates, user.PersonalEmailContains(*i.PersonalEmailContains))
	}
	if i.PersonalEmailHasPrefix != nil {
		predicates = append(predicates, user.PersonalEmailHasPrefix(*i.PersonalEmailHasPrefix))
	}
	if i.PersonalEmailHasSuffix != nil {
		predicates = append(predicates, user.PersonalEmailHasSuffix(*i.PersonalEmailHasSuffix))
	}
	if i.PersonalEmailIsNil {
		predicates = append(predicates, user.PersonalEmailIsNil())
	}
	if i.PersonalEmailNotNil {
		predicates = append(predicates, user.PersonalEmailNotNil())
	}
	if i.PersonalEmailEqualFold != nil {
		predicates = append(predicates, user.PersonalEmailEqualFold(*i.PersonalEmailEqualFold))
	}
	if i.PersonalEmailContainsFold != nil {
		predicates = append(predicates, user.PersonalEmailContainsFold(*i.PersonalEmailContainsFold))
	}
	if i.IntranetWorkEmail != nil {
		predicates = append(predicates, user.IntranetWorkEmailEQ(*i.IntranetWorkEmail))
	}
	if i.IntranetWorkEmailNEQ != nil {
		predicates = append(predicates, user.IntranetWorkEmailNEQ(*i.IntranetWorkEmailNEQ))
	}
	if len(i.IntranetWorkEmailIn) > 0 {
		predicates = append(predicates, user.IntranetWorkEmailIn(i.IntranetWorkEmailIn...))
	}
	if len(i.IntranetWorkEmailNotIn) > 0 {
		predicates = append(predicates, user.IntranetWorkEmailNotIn(i.IntranetWorkEmailNotIn...))
	}
	if i.IntranetWorkEmailGT != nil {
		predicates = append(predicates, user.IntranetWorkEmailGT(*i.IntranetWorkEmailGT))
	}
	if i.IntranetWorkEmailGTE != nil {
		predicates = append(predicates, user.IntranetWorkEmailGTE(*i.IntranetWorkEmailGTE))
	}
	if i.IntranetWorkEmailLT != nil {
		predicates = append(predicates, user.IntranetWorkEmailLT(*i.IntranetWorkEmailLT))
	}
	if i.IntranetWorkEmailLTE != nil {
		predicates = append(predicates, user.IntranetWorkEmailLTE(*i.IntranetWorkEmailLTE))
	}
	if i.IntranetWorkEmailContains != nil {
		predicates = append(predicates, user.IntranetWorkEmailContains(*i.IntranetWorkEmailContains))
	}
	if i.IntranetWorkEmailHasPrefix != nil {
		predicates = append(predicates, user.IntranetWorkEmailHasPrefix(*i.IntranetWorkEmailHasPrefix))
	}
	if i.IntranetWorkEmailHasSuffix != nil {
		predicates = append(predicates, user.IntranetWorkEmailHasSuffix(*i.IntranetWorkEmailHasSuffix))
	}
	if i.IntranetWorkEmailEqualFold != nil {
		predicates = append(predicates, user.IntranetWorkEmailEqualFold(*i.IntranetWorkEmailEqualFold))
	}
	if i.IntranetWorkEmailContainsFold != nil {
		predicates = append(predicates, user.IntranetWorkEmailContainsFold(*i.IntranetWorkEmailContainsFold))
	}
	if i.ExtranetWorkEmail != nil {
		predicates = append(predicates, user.ExtranetWorkEmailEQ(*i.ExtranetWorkEmail))
	}
	if i.ExtranetWorkEmailNEQ != nil {
		predicates = append(predicates, user.ExtranetWorkEmailNEQ(*i.ExtranetWorkEmailNEQ))
	}
	if len(i.ExtranetWorkEmailIn) > 0 {
		predicates = append(predicates, user.ExtranetWorkEmailIn(i.ExtranetWorkEmailIn...))
	}
	if len(i.ExtranetWorkEmailNotIn) > 0 {
		predicates = append(predicates, user.ExtranetWorkEmailNotIn(i.ExtranetWorkEmailNotIn...))
	}
	if i.ExtranetWorkEmailGT != nil {
		predicates = append(predicates, user.ExtranetWorkEmailGT(*i.ExtranetWorkEmailGT))
	}
	if i.ExtranetWorkEmailGTE != nil {
		predicates = append(predicates, user.ExtranetWorkEmailGTE(*i.ExtranetWorkEmailGTE))
	}
	if i.ExtranetWorkEmailLT != nil {
		predicates = append(predicates, user.ExtranetWorkEmailLT(*i.ExtranetWorkEmailLT))
	}
	if i.ExtranetWorkEmailLTE != nil {
		predicates = append(predicates, user.ExtranetWorkEmailLTE(*i.ExtranetWorkEmailLTE))
	}
	if i.ExtranetWorkEmailContains != nil {
		predicates = append(predicates, user.ExtranetWorkEmailContains(*i.ExtranetWorkEmailContains))
	}
	if i.ExtranetWorkEmailHasPrefix != nil {
		predicates = append(predicates, user.ExtranetWorkEmailHasPrefix(*i.ExtranetWorkEmailHasPrefix))
	}
	if i.ExtranetWorkEmailHasSuffix != nil {
		predicates = append(predicates, user.ExtranetWorkEmailHasSuffix(*i.ExtranetWorkEmailHasSuffix))
	}
	if i.ExtranetWorkEmailIsNil {
		predicates = append(predicates, user.ExtranetWorkEmailIsNil())
	}
	if i.ExtranetWorkEmailNotNil {
		predicates = append(predicates, user.ExtranetWorkEmailNotNil())
	}
	if i.ExtranetWorkEmailEqualFold != nil {
		predicates = append(predicates, user.ExtranetWorkEmailEqualFold(*i.ExtranetWorkEmailEqualFold))
	}
	if i.ExtranetWorkEmailContainsFold != nil {
		predicates = append(predicates, user.ExtranetWorkEmailContainsFold(*i.ExtranetWorkEmailContainsFold))
	}

	if i.HasCreateBy != nil {
		p := user.HasCreateBy()
		if !*i.HasCreateBy {
			p = user.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCreateByWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasCreateByWith))
		for _, w := range i.HasCreateByWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, user.HasCreateByWith(with...))
	}
	if i.HasUpdateBy != nil {
		p := user.HasUpdateBy()
		if !*i.HasUpdateBy {
			p = user.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasUpdateByWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasUpdateByWith))
		for _, w := range i.HasUpdateByWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, user.HasUpdateByWith(with...))
	}
	if i.HasAuthHistories != nil {
		p := user.HasAuthHistories()
		if !*i.HasAuthHistories {
			p = user.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasAuthHistoriesWith) > 0 {
		with := make([]predicate.Auth, 0, len(i.HasAuthHistoriesWith))
		for _, w := range i.HasAuthHistoriesWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, user.HasAuthHistoriesWith(with...))
	}
	if i.HasJobHistories != nil {
		p := user.HasJobHistories()
		if !*i.HasJobHistories {
			p = user.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasJobHistoriesWith) > 0 {
		with := make([]predicate.JobHistory, 0, len(i.HasJobHistoriesWith))
		for _, w := range i.HasJobHistoriesWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, user.HasJobHistoriesWith(with...))
	}
	if i.HasCreates != nil {
		p := user.HasCreates()
		if !*i.HasCreates {
			p = user.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCreatesWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasCreatesWith))
		for _, w := range i.HasCreatesWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, user.HasCreatesWith(with...))
	}
	if i.HasUpdates != nil {
		p := user.HasUpdates()
		if !*i.HasUpdates {
			p = user.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasUpdatesWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasUpdatesWith))
		for _, w := range i.HasUpdatesWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, user.HasUpdatesWith(with...))
	}
	if i.HasBelongToOrgUnitMembers != nil {
		p := user.HasBelongToOrgUnitMembers()
		if !*i.HasBelongToOrgUnitMembers {
			p = user.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasBelongToOrgUnitMembersWith) > 0 {
		with := make([]predicate.OrgUnitMember, 0, len(i.HasBelongToOrgUnitMembersWith))
		for _, w := range i.HasBelongToOrgUnitMembersWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, user.HasBelongToOrgUnitMembersWith(with...))
	}
	if i.HasBelongToOg != nil {
		p := user.HasBelongToOg()
		if !*i.HasBelongToOg {
			p = user.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasBelongToOgWith) > 0 {
		with := make([]predicate.Organization, 0, len(i.HasBelongToOgWith))
		for _, w := range i.HasBelongToOgWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, user.HasBelongToOgWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, fmt.Errorf("wing/models/ent: empty predicate UserWhereInput")
	case 1:
		return predicates[0], nil
	default:
		return user.And(predicates...), nil
	}
}
